# 有效的括号

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }

    for _, char := range s {
        switch char {
        case '(', '{', '[':
            stack = append(stack, char)
        case ')', '}', ']':
            if len(stack) == 0 || stack[len(stack)-1] != pairs[char] {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}
```

1. **初始化栈和括号映射**：
   - `stack` 用于存储遇到的左括号。
   - `pairs` 是一个映射，键是右括号，值是对应的左括号。
2. **遍历字符串**：
   - 遇到左括号 `(`, `{`, `[` 时，将其压入栈中。
   - 遇到右括号 `)`, `}`, `]` 时：
     - 检查栈是否为空（若为空，说明没有对应的左括号，直接返回 `false`）。
     - 检查栈顶的左括号是否与当前右括号匹配（若不匹配，返回 `false`）。
     - 匹配则弹出栈顶元素。
3. **最终检查**：
   - 若栈为空，说明所有括号都正确闭合，返回 `true`；否则返回 `false`。

# 最小栈

```go
type MinStack struct {
    stack    []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack:    make([]int, 0),
        minStack: make([]int, 0),
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if len(this.minStack) == 0 || val <= this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    }
}

func (this *MinStack) Pop() {
    if len(this.stack) == 0 {
        return
    }
    popped := this.stack[len(this.stack)-1]
    this.stack = this.stack[:len(this.stack)-1]
    if popped == this.minStack[len(this.minStack)-1] {
        this.minStack = this.minStack[:len(this.minStack)-1]
    }
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

1. **数据结构**：
   - `stack`：主栈，存储所有元素。
   - `minStack`：辅助栈，存储当前的最小值。
2. **`Push` 操作**：
   - 将 `val` 压入 `stack`。
   - 如果 `minStack` 为空或 `val` 小于等于 `minStack` 的栈顶元素，将 `val` 压入 `minStack`。
3. **`Pop` 操作**：
   - 弹出 `stack` 的栈顶元素。
   - 如果弹出的元素等于 `minStack` 的栈顶元素，同时弹出 `minStack` 的栈顶元素（因为该最小值已不再存在于 `stack` 中）。
4. **`Top` 操作**：
   - 返回 `stack` 的栈顶元素。
5. **`GetMin` 操作**：
   - 返回 `minStack` 的栈顶元素（即当前最小值）。

# 字符串解码

```go
import (
	"strconv"
	"strings"
)

func decodeString(s string) string {
	stack := []struct {
		str string
		num int
	}{}
	currentStr := ""
	currentNum := 0

	for _, char := range s {
		if char >= '0' && char <= '9' {
			num, _ := strconv.Atoi(string(char))
			currentNum = currentNum*10 + num
		} else if char == '[' {
			stack = append(stack, struct {
				str string
				num int
			}{currentStr, currentNum})
			currentStr = ""
			currentNum = 0
		} else if char == ']' {
			last := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			currentStr = last.str + strings.Repeat(currentStr, last.num)
		} else {
			currentStr += string(char)
		}
	}

	return currentStr
}
```

1. **初始化**：`stack` 用于保存之前的字符串和数字，`currentStr` 保存当前正在构建的字符串，`currentNum` 保存当前解析的数字。
2. **遍历字符**：
   - **数字处理**：如果是数字，更新 `currentNum`，处理多位数字的情况。
   - **左括号处理**：遇到 `[` 时，将当前的 `currentStr` 和 `currentNum` 压入栈，并重置这两个变量以处理嵌套结构。
   - **右括号处理**：遇到 `]` 时，从栈中弹出之前存储的字符串和数字，将当前字符串重复数字次，然后与弹出的字符串拼接。
   - **字母处理**：遇到字母时，直接添加到 `currentStr`。
3. **返回结果**：最终 `currentStr` 即为解码后的字符串。

# 每日温度

```go
func dailyTemperatures(temperatures []int) []int {
    n := len(temperatures)
    answer := make([]int, n)
    stack := []int{} // 栈中存储的是温度的索引

    for i := 0; i < n; i++ {
        // 当栈不为空且当前温度大于栈顶温度时
        for len(stack) > 0 && temperatures[i] > temperatures[stack[len(stack)-1]] {
            prevIndex := stack[len(stack)-1]
            stack = stack[:len(stack)-1] // 弹出栈顶元素
            answer[prevIndex] = i - prevIndex // 计算天数差
        }
        stack = append(stack, i) // 将当前索引入栈
    }

    return answer
}

```

1. **初始化**：`answer`数组用于存储结果，初始化为0。`stack`用于保存温度的索引，初始为空。
2. **遍历温度数组**：
   - **内层循环**：检查栈顶温度是否小于当前温度。如果是，计算栈顶温度的下一个更高温度的天数差，并更新`answer`数组，然后弹出栈顶元素。
   - **索引入栈**：将当前温度的索引入栈，以便后续处理。
3. **返回结果**：遍历结束后，`answer`数组即为所求，其中未被更新的位置保持为0，表示没有更高的温度。

# 柱状图中最大的矩形（难）