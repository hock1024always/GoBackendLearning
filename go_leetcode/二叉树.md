# 二叉树的中序遍历

## 解题代码

### 递归法

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    //使用递归法来解决
    var result []int 
    inorder(root,&result)
    return result
}

func inorder(root *TreeNode , result *[]int){
    //判断该节点是否为nil
    if(root == nil){
        return
    }

    //中序遍历在代码中的体现就是递归代码中放中间
    inorder(root.Left,result)
    *result = append(*result,root.Val)
    inorder(root.Right,result)
}
```

更好的写法是下面的root换成node

### 使用栈的迭代法

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    var result []int
    stack := []*TreeNode{}
    current := root

    for current != nil || len(stack) > 0 {
        // 遍历到最左节点，沿途压栈
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }
        // 弹出栈顶元素
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, current.Val)
        // 转向右子树
        current = current.Right
    }
    return result
}
```

## 语法点回顾

### 递归的前中后序遍历

1. 前中后序遍历在代码中就是操作语句放在左右节点的同名函数前、中还是后

### 栈的使用

1. 首先使用的是数组去模拟栈的实现，在切片中采用了`current = stack[len(stack)-1]  stack = stack[:len(stack)-1]`这样的写法来将一个切片作为栈来使用
2. 将左节点放入栈中，本质上就相当于是将左节点进行递归操作

# 二叉树的最大深度

## 解题方法

### 方法一：递归法（DFS）

这是最直观的解决方法。二叉树的最大深度等于其左右子树的最大深度加1。

算法步骤：

1. 如果根节点为空，返回0
2. 递归计算左子树的最大深度
3. 递归计算右子树的最大深度
4. 返回左右子树最大深度中的较大值加1

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return max(leftDepth, rightDepth) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 方法二：迭代法（BFS）

使用层序遍历，每遍历一层，深度加1，直到遍历完所有层。

```go
func maxDepth(root *TreeNode) int {
    depth := 0
    if root == nil{
        return 0
    }
    //定义队列
    queue := []*TreeNode{root}
    //遍历这个队列、直到队列为空
    for len(queue) > 0{
        levelSize := len(queue)
        //对整个层的节点都进行这个操作
        for i := 0; i < levelSize; i++{
            //出队
            node := queue[0]
            queue = queue[1:]
            //检查左右节点并且入队 
            if node.Left != nil{
                queue = append(queue , node.Left)
            }
            if node.Right != nil{
                queue = append(queue , node.Right)
            }
        } 
        depth++
    }
    return depth
}
```

在这个方法中，还是还很巧妙的使用了切片实现了简单的队列：

1. **队列的定义：** `queue := []*TreeNode{root}`
2. **出队操作：** `node := queue[0]    queue = queue[1:]`
3. **入队操作：** `queue = append(queue, node.Left)`

# 翻转二叉树

## 解题思路

### 方法一：递归法

最终呈现的效果是先去进行对每一个最小子树进行左右交换，之后对上一级子树进行直到到达根节点

这是最直观的解决方法：

1. 如果当前节点为空，直接返回
2. 递归翻转左子树
3. 递归翻转右子树
4. 交换当前节点的左右子树

```go
func invertTree(root *TreeNode) *TreeNode {
    //终结条件：首先进行，判空返回
    if root == nil{
        return nil
    }

    //递归执行
    root.Left = invertTree(root.Left)
    root.Right = invertTree(root.Right)       

    //交换左右侧
    left := root.Right
    root.Right = root.Left
    root.Left = left
    

    return root
}
```

### 方法二：迭代法（BFS）

使用层序遍历，在遍历每个节点时交换其左右子节点。

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        
        // 交换左右子节点
        node.Left, node.Right = node.Right, node.Left
        
        // 将子节点加入队列
        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
    }
    
    return root
}
```

# 对称二叉树

## 解题方法

### 方法一：递归法

1. 定义辅助函数检查两棵树是否镜像对称
2. 比较根节点的左右子树是否互为镜像
3. 镜像条件：
   - 两个节点值相等
   - 左子树的左子树与右子树的右子树对称
   - 左子树的右子树与右子树的左子树对称

```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isMirror(root.Left, root.Right)
}

func isMirror(left, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }
    if left == nil || right == nil {
        return false
    }
    return left.Val == right.Val && 
           isMirror(left.Left, right.Right) && 
           isMirror(left.Right, right.Left)
}
```

下面这个返回值比较巧妙：
```go
return left.Val == right.Val && 
           isMirror(left.Left, right.Right) && 
           isMirror(left.Right, right.Left)
```

### 方法二：迭代法（队列）

使用队列来同时比较对称位置的节点

```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    
    queue := []*TreeNode{root.Left, root.Right}
    
    for len(queue) > 0 {
        left := queue[0]
        right := queue[1]
        queue = queue[2:]
        
        if left == nil && right == nil {
            continue
        }
        if left == nil || right == nil {
            return false
        }
        if left.Val != right.Val {
            return false
        }
        
        queue = append(queue, left.Left, right.Right)
        queue = append(queue, left.Right, right.Left)
    }
    
    return true
}
```

这个题目的递归就记住左节点的左子节点和右节点的右子节点进行比较

# 二叉树的直径

## 解题方法

### 递归计算高度

1. 对于每个节点，直径长度等于左子树高度 + 右子树高度
2. 我们需要在计算树高度的同时，记录最大直径
3. 使用一个全局变量来跟踪最大直径
4. 递归计算每个节点的高度（1 + max(左高度, 右高度)）

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func diameterOfBinaryTree(root *TreeNode) int {
    maxDiameter := 0
    var depth func(*TreeNode) int
    depth = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        leftDepth := depth(node.Left)
        rightDepth := depth(node.Right)
        // 更新最大直径
        maxDiameter = max(maxDiameter, leftDepth + rightDepth)
        // 返回当前节点的高度
        return max(leftDepth, rightDepth) + 1
    }
    depth(root)
    return maxDiameter
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

# 二叉树的层序遍历









# 将有序数组转换为二叉搜索树









# 验证二叉搜索树









# 二叉搜索树中第 K 小的元素









# 二叉树的右视图











# 二叉树展开为链表











# 从前序与中序遍历序列构造二叉树









# 路径总和 III











# 二叉树的最近公共祖先













# 二叉树中的最大路径和（难）









