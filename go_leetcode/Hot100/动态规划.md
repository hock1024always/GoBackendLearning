# 爬楼梯

1. **初始化**：定义前两个台阶的方法数，即dp[1] = 1，dp[2] = 2。
2. **递推关系**：对于每个台阶i（从3到n），dp[i] = dp[i-1] + dp[i-2]。
3. **空间优化**：由于只需要前两个值来计算当前值，可以用两个变量代替整个数组，将空间复杂度优化到O(1)。

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    prev, curr := 1, 2
    for i := 3; i <= n; i++ {
        next := prev + curr
        prev = curr
        curr = next
    }
    return curr
}
```

# 杨辉三角

杨辉三角是一个经典的数学问题，每个数是它左上方和右上方的数的和。生成杨辉三角的前numRows行，可以按照以下步骤进行：

1. **初始化**：第一行是[1]，第二行是[1, 1]。
2. **递推关系**：对于第i行（i >= 2），第j个数等于上一行的第j-1个数加上第j个数（如果存在的话）。
3. **边界处理**：每一行的第一个和最后一个数都是1。

```go
func generate(numRows int) [][]int {
    if numRows == 0 {
        return [][]int{}
    }
    triangle := make([][]int, numRows)
    triangle[0] = []int{1}
    for i := 1; i < numRows; i++ {
        row := make([]int, i+1)
        row[0], row[i] = 1, 1
        for j := 1; j < i; j++ {
            row[j] = triangle[i-1][j-1] + triangle[i-1][j]
        }
        triangle[i] = row
    }
    return triangle
}
```

# 打家劫舍

### 打家劫舍问题

#### 方法思路
这个问题可以使用动态规划来解决。关键在于找到状态转移方程。对于第i个房屋，小偷有两种选择：

1. **偷窃第i个房屋**：那么不能偷窃第i-1个房屋，最大金额为前i-2个房屋的最大金额加上当前房屋的金额。
2. **不偷窃第i个房屋**：那么最大金额为前i-1个房屋的最大金额。

因此，状态转移方程为：
dp[i] = max(dp[i-1], dp[i-2] + nums[i])

#### 解决代码
```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    }
    return dp[len(nums)-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始条件处理**：如果房屋数量为0，返回0；如果只有一间房屋，返回该房屋的金额。
2. **初始化`dp`数组**：`dp[0]`为第一间房屋的金额，`dp[1]`为前两间房屋中金额较大的一个。
3. **动态规划填充`dp`数组**：从第三间房屋开始，根据状态转移方程计算`dp[i]`。
4. **返回结果**：`dp`数组的最后一个元素即为能够偷窃到的最高金额。

这种方法的时间复杂度为O(n)，空间复杂度为O(n)，可以通过优化将空间复杂度降至O(1)。

# 完全平方数

#### 方法思路
这个问题可以使用动态规划来解决。我们需要找到和为`n`的完全平方数的最少数量。关键在于定义状态和状态转移方程。

1. **状态定义**：`dp[i]`表示和为`i`的完全平方数的最少数量。
2. **初始状态**：`dp[0] = 0`，因为和为0不需要任何完全平方数。
3. **状态转移**：对于每个数`i`，遍历所有可能的完全平方数`j*j`（其中`j*j <= i`），更新`dp[i] = min(dp[i], dp[i - j*j] + 1)`。
4. **结果获取**：`dp[n]`即为所求。

#### 解决代码
```go
import "math"

func numSquares(n int) int {
    dp := make([]int, n+1)
    for i := 1; i <= n; i++ {
        dp[i] = math.MaxInt32
        for j := 1; j*j <= i; j++ {
            dp[i] = min(dp[i], dp[i-j*j]+1)
        }
    }
    return dp[n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始化dp数组**：`dp`数组的大小为`n + 1`，初始时`dp[0] = 0`，其余为`math.MaxInt32`。
2. **动态规划填充dp数组**：对于每个数`i`，遍历所有可能的完全平方数`j*j`，更新`dp[i]`为最小值。
3. **返回结果**：`dp[n]`即为和为`n`的完全平方数的最少数量。

这种方法的时间复杂度为O(n * sqrt(n))，空间复杂度为O(n)。

#### 优化思路
可以使用数学方法进一步优化。根据四平方和定理，任何自然数都可以表示为最多四个平方数的和。因此，我们可以先检查是否满足以下情况：
1. 如果`n`是完全平方数，返回1。
2. 如果`n`可以表示为两个平方数的和，返回2。
3. 如果`n`满足`n = 4^k*(8m + 7)`的形式，返回4。
4. 否则返回3。

#### 优化后的代码
```go
import "math"

func numSquares(n int) int {
    // 检查是否是完全平方数
    if isPerfectSquare(n) {
        return 1
    }
    // 检查是否可以表示为两个平方数的和
    for i := 1; i*i <= n; i++ {
        if isPerfectSquare(n - i*i) {
            return 2
        }
    }
    // 检查是否满足n = 4^k*(8m + 7)
    for n%4 == 0 {
        n /= 4
    }
    if n%8 == 7 {
        return 4
    }
    // 其他情况返回3
    return 3
}

func isPerfectSquare(n int) bool {
    sqrt := int(math.Sqrt(float64(n)))
    return sqrt*sqrt == n
}
```

#### 优化代码解释
1. **检查完全平方数**：使用`isPerfectSquare`函数检查`n`是否是完全平方数。
2. **检查两个平方数的和**：遍历所有可能的平方数，检查`n`是否可以表示为两个平方数的和。
3. **检查四平方和定理的特殊情况**：如果`n`满足`n = 4^k*(8m + 7)`的形式，返回4。
4. **其他情况**：如果不满足上述情况，返回3。

这种方法的时间复杂度为O(sqrt(n))，空间复杂度为O(1)，效率更高。

# 零钱兑换

#### 方法思路
这是一个典型的动态规划问题，类似于完全背包问题。我们需要找到组成目标金额所需的最少硬币数。关键在于定义状态和状态转移方程。

1. **状态定义**：dp[i]表示组成金额i所需的最少硬币数。
2. **初始状态**：dp[0] = 0，因为金额为0时不需要任何硬币。
3. **状态转移**：对于每个金额i，遍历所有硬币面额coin。如果coin <= i，则dp[i] = min(dp[i], dp[i - coin] + 1)。
4. **边界处理**：如果dp[amount]仍为初始值（表示无法组成该金额），返回-1。

#### 解决代码
```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount + 1)
    for i := 1; i <= amount; i++ {
        dp[i] = amount + 1 // 初始化为一个较大的值
    }
    dp[0] = 0
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if coin <= i {
                dp[i] = min(dp[i], dp[i - coin] + 1)
            }
        }
    }
    if dp[amount] > amount {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始化dp数组**：dp数组的大小为amount + 1，初始时除dp[0]外都设为amount + 1（表示无法达到）。
2. **动态规划填充dp数组**：对于每个金额i，遍历所有硬币面额，更新dp[i]为最小值。
3. **结果判断**：如果dp[amount]未被更新（仍大于amount），返回-1；否则返回dp[amount]。

这种方法的时间复杂度为O(amount * n)，其中n为硬币种类数。空间复杂度为O(amount)。



# 单词拆分



#### 方法思路
这个问题可以使用动态规划来解决。我们需要判断字符串`s`是否可以由字典`wordDict`中的单词拼接而成。关键在于定义状态和状态转移方程。

1. **状态定义**：`dp[i]`表示字符串`s`的前`i`个字符是否可以由字典中的单词拼接而成。
2. **初始状态**：`dp[0] = true`，表示空字符串可以被拼接。
3. **状态转移**：对于每个位置`i`，遍历所有可能的单词`word`，如果`s`的前`i`个字符以`word`结尾，并且`dp[i - len(word)]`为`true`，则`dp[i] = true`。
4. **结果获取**：`dp[len(s)]`即为所求。

#### 解决代码
```go
func wordBreak(s string, wordDict []string) bool {
    wordSet := make(map[string]bool)
    for _, word := range wordDict {
        wordSet[word] = true
    }
    dp := make([]bool, len(s)+1)
    dp[0] = true
    for i := 1; i <= len(s); i++ {
        for j := 0; j < i; j++ {
            if dp[j] && wordSet[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }
    return dp[len(s)]
}
```

#### 代码解释
1. **构建单词集合**：将`wordDict`转换为一个集合`wordSet`，便于快速查找。
2. **初始化dp数组**：`dp`数组的大小为`len(s) + 1`，初始时`dp[0] = true`。
3. **动态规划填充dp数组**：对于每个位置`i`，检查所有可能的分割点`j`，如果`s[j:i]`在`wordSet`中且`dp[j]`为`true`，则`dp[i] = true`。
4. **返回结果**：`dp[len(s)]`即为字符串`s`是否可以由字典中的单词拼接而成。

这种方法的时间复杂度为O(n^2)，其中`n`为字符串`s`的长度。空间复杂度为O(n)。



# 最长递增子序列

#### 方法思路
这个问题可以使用动态规划来解决。我们需要找到数组中最长的严格递增子序列的长度。关键在于定义状态和状态转移方程。

1. **状态定义**：dp[i]表示以nums[i]结尾的最长递增子序列的长度。
2. **初始状态**：每个元素本身就是一个长度为1的子序列，所以初始时dp[i] = 1。
3. **状态转移**：对于每个元素nums[i]，遍历之前的所有元素nums[j]（j < i），如果nums[i] > nums[j]，则更新dp[i] = max(dp[i], dp[j] + 1)。
4. **结果获取**：遍历dp数组，找到最大值即为最长递增子序列的长度。

#### 解决代码
```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    maxLen := 1
    for i := 0; i < len(nums); i++ {
        dp[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始条件处理**：如果数组为空，返回0。
2. **初始化dp数组**：每个元素的初始长度为1。
3. **动态规划填充dp数组**：对于每个元素nums[i]，遍历之前的所有元素nums[j]，如果nums[i] > nums[j]，则更新dp[i]。
4. **结果获取**：在填充dp数组的同时，记录最大值maxLen，最后返回maxLen。

这种方法的时间复杂度为O(n^2)，其中n为数组长度。空间复杂度为O(n)。

# 乘积最大子数组

#### 方法思路
这个问题可以使用动态规划来解决。关键在于处理负数乘积的情况，因为负数乘以负数会变成正数。我们需要同时记录当前的最大乘积和最小乘积。

1. **状态定义**：
   - `maxDP[i]`表示以`nums[i]`结尾的子数组的最大乘积。
   - `minDP[i]`表示以`nums[i]`结尾的子数组的最小乘积。
2. **初始状态**：`maxDP[0] = minDP[0] = nums[0]`。
3. **状态转移**：
   - 如果`nums[i]`为正数，`maxDP[i] = max(nums[i], maxDP[i-1] * nums[i])`，`minDP[i] = min(nums[i], minDP[i-1] * nums[i])`。
   - 如果`nums[i]`为负数，`maxDP[i] = max(nums[i], minDP[i-1] * nums[i])`，`minDP[i] = min(nums[i], maxDP[i-1] * nums[i])`。
4. **结果获取**：遍历过程中记录最大的`maxDP[i]`。

#### 解决代码
```go
func maxProduct(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    maxDP := make([]int, len(nums))
    minDP := make([]int, len(nums))
    maxDP[0], minDP[0] = nums[0], nums[0]
    res := nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] >= 0 {
            maxDP[i] = max(nums[i], maxDP[i-1] * nums[i])
            minDP[i] = min(nums[i], minDP[i-1] * nums[i])
        } else {
            maxDP[i] = max(nums[i], minDP[i-1] * nums[i])
            minDP[i] = min(nums[i], maxDP[i-1] * nums[i])
        }
        res = max(res, maxDP[i])
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始条件处理**：如果数组为空，返回0。
2. **初始化dp数组**：`maxDP`和`minDP`数组的第一个元素为`nums[0]`。
3. **动态规划填充dp数组**：根据当前元素的正负情况，更新`maxDP`和`minDP`。
4. **结果获取**：在填充dp数组的同时，记录最大值`res`，最后返回`res`。

这种方法的时间复杂度为O(n)，空间复杂度为O(n)。可以通过优化将空间复杂度降至O(1)。

# 分割等和子集

### 分割等和子集问题

#### 方法思路
这个问题可以转化为一个背包问题。我们需要判断是否存在一个子集，其和等于数组总和的一半。具体步骤如下：

1. **计算总和**：首先计算数组的总和`sum`。如果`sum`为奇数，直接返回`false`，因为无法分成两个和相等的子集。
2. **目标值**：目标是找到子集的和为`sum/2`。
3. **动态规划**：使用一个布尔数组`dp`，其中`dp[i]`表示是否存在一个子集的和为`i`。
4. **初始化**：`dp[0] = true`，因为和为0的子集总是存在（空集）。
5. **状态转移**：对于每个数字`num`，从`sum/2`倒序遍历到`num`，更新`dp[i] = dp[i] || dp[i - num]`。
6. **结果判断**：`dp[sum/2]`即为是否存在这样的子集。

#### 解决代码
```go
func canPartition(nums []int) bool {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    if sum % 2 != 0 {
        return false
    }
    target := sum / 2
    dp := make([]bool, target + 1)
    dp[0] = true
    for _, num := range nums {
        for i := target; i >= num; i-- {
            dp[i] = dp[i] || dp[i - num]
        }
    }
    return dp[target]
}
```

#### 代码解释
1. **计算总和**：遍历数组计算总和`sum`。
2. **判断奇偶**：如果`sum`为奇数，直接返回`false`。
3. **初始化dp数组**：`dp`数组的大小为`target + 1`，初始时只有`dp[0]`为`true`。
4. **动态规划填充dp数组**：对于每个数字`num`，从`target`倒序遍历到`num`，更新`dp[i]`。
5. **返回结果**：`dp[target]`即为是否存在和为`target`的子集。

这种方法的时间复杂度为O(n * target)，空间复杂度为O(target)，其中`n`为数组长度，`target`为数组总和的一半。



# 最长有效括号（难）