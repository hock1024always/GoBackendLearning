# 无重复字符串的最长子串

```go
func lengthOfLongestSubstring(s string) int {
    charIndex := make(map[byte]int)
    maxLength := 0
    left := 0

    for right := 0; right < len(s); right++ {
        if index, found := charIndex[s[right]]; found && index >= left {
            left = index + 1
        }
        charIndex[s[right]] = right
        currentLength := right - left + 1
        if currentLength > maxLength {
            maxLength = currentLength
        }
    }

    return maxLength
}
```

1. **初始化**：`charIndex`用于存储字符及其最新索引，`maxLength`记录最长子串长度，`left`表示窗口左边界。
2. **遍历字符串**：`right`指针从0开始，逐步向右移动。
3. **检查重复字符**：如果当前字符`s[right]`已在`charIndex`中且其索引大于等于`left`，说明该字符在当前窗口内重复出现，移动`left`到重复字符的下一个位置。
4. **更新字符位置**：将当前字符及其位置存入`charIndex`。
5. **计算窗口长度**：当前窗口长度为`right - left + 1`，更新`maxLength`。
6. **返回结果**：遍历结束后，`maxLength`即为不含重复字符的最长子串的长度



# 找到字符串中所有字母异位词

```go
func findAnagrams(s string, p string) []int {
    if len(s) < len(p) {
        return []int{}
    }

    pCount := make([]int, 26)
    sCount := make([]int, 26)
    result := []int{}

    for i := 0; i < len(p); i++ {
        pCount[p[i]-'a']++
        sCount[s[i]-'a']++
    }

    if isEqual(pCount, sCount) {
        result = append(result, 0)
    }

    for i := len(p); i < len(s); i++ {
        sCount[s[i-len(p)]-'a']--
        sCount[s[i]-'a']++
        if isEqual(pCount, sCount) {
            result = append(result, i-len(p)+1)
        }
    }

    return result
}

func isEqual(a, b []int) bool {
    for i := 0; i < 26; i++ {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

1. **初始化频率数组**：`pCount`和`sCount`分别用于统计`p`和当前窗口内字符的频率。
2. **初始窗口处理**：统计`p`的字符频率和`s`前`len(p)`个字符的频率，比较是否相同，若相同则记录起始索引0。
3. **滑动窗口遍历**：从`len(p)`开始遍历`s`，每次移动窗口时，移除左边界的字符（频率减1），添加右边界的字符（频率加1），然后比较频率数组，若相同则记录当前窗口的起始索引。
4. **比较频率数组**：`isEqual`函数用于比较两个频率数组是否完全相同。
5. **返回结果**：最终返回所有符合条件的起始索引列表。