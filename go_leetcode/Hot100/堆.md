# 数组中的第K个最大元素

```go
import "math/rand"

func findKthLargest(nums []int, k int) int {
    return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}

func quickSelect(nums []int, left, right, k int) int {
    if left == right {
        return nums[left]
    }
    pivotIndex := partition(nums, left, right)
    if k == pivotIndex {
        return nums[k]
    } else if k < pivotIndex {
        return quickSelect(nums, left, pivotIndex-1, k)
    } else {
        return quickSelect(nums, pivotIndex+1, right, k)
    }
}

func partition(nums []int, left, right int) int {
    pivotIndex := left + rand.Intn(right-left+1)
    pivot := nums[pivotIndex]
    nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]
    storeIndex := left
    for i := left; i < right; i++ {
        if nums[i] < pivot {
            nums[storeIndex], nums[i] = nums[i], nums[storeIndex]
            storeIndex++
        }
    }
    nums[storeIndex], nums[right] = nums[right], nums[storeIndex]
    return storeIndex
}
```

1. **findKthLargest函数**：这是主函数，调用quickSelect来找到第k大的元素。由于quickSelect查找的是第k小的元素，所以传入的参数是`len(nums)-k`。
2. **quickSelect函数**：递归地进行快速选择。
   - **基准情况**：如果左右指针相遇，返回当前元素。
   - **分区操作**：调用partition函数获取主元的位置。
   - **递归选择**：根据主元位置与k的比较，决定继续在左半部分或右半部分查找。
3. **partition函数**：随机选择一个主元，并将数组分为小于主元和大于主元的两部分。
   - **随机选择主元**：避免最坏情况的发生。
   - **交换和分区**：将小于主元的元素移到左边，大于主元的元素移到右边，最后将主元放到正确的位置，并返回其索引。

# 前 K 个高频元素

```go
import (
	"container/heap"
)

func topKFrequent(nums []int, k int) []int {
	freqMap := make(map[int]int)
	for _, num := range nums {
		freqMap[num]++
	}

	h := &MinHeap{}
	heap.Init(h)

	for num, freq := range freqMap {
		heap.Push(h, Element{num, freq})
		if h.Len() > k {
			heap.Pop(h)
		}
	}

	res := make([]int, k)
	for i := 0; i < k; i++ {
		res[k-1-i] = heap.Pop(h).(Element).num
	}
	return res
}

type Element struct {
	num  int
	freq int
}

type MinHeap []Element

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i].freq < h[j].freq }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *MinHeap) Push(x interface{}) {
	*h = append(*h, x.(Element))
}

func (h *MinHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}
```

1. **统计频率**：使用`freqMap`哈希表统计每个数字出现的频率。
2. **初始化最小堆**：定义`MinHeap`类型并实现堆的接口方法（`Len`, `Less`, `Swap`, `Push`, `Pop`）。
3. **处理堆**：遍历频率哈希表，将每个元素及其频率推入堆中。如果堆的大小超过k，则弹出堆顶元素，确保堆的大小始终不超过k。
4. **获取结果**：最后，从堆中依次弹出元素，由于是最小堆，弹出的顺序是从小到大，所以需要逆序存储到结果数组中。

# 数据流的中位数（难）