# 不同路径

#### 方法思路
这个问题可以使用动态规划来解决。我们需要计算从网格的左上角到右下角的所有可能路径数，其中机器人只能向右或向下移动。

1. **状态定义**：`dp[i][j]`表示到达网格第`i`行第`j`列的不同路径数。
2. **初始状态**：第一行和第一列的路径数都是1，因为只有一种方式到达（一直向右或一直向下）。
3. **状态转移**：对于其他位置`(i, j)`，路径数等于上方和左方路径数之和，即`dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
4. **结果获取**：`dp[m-1][n-1]`即为所求。

#### 解决代码
```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```

#### 代码解释
1. **初始化dp数组**：创建一个`m x n`的二维数组`dp`，并将第一行和第一列初始化为1。
2. **动态规划填充dp数组**：对于每个位置`(i, j)`，计算`dp[i][j]`为上方和左方路径数之和。
3. **返回结果**：`dp[m-1][n-1]`即为从左上角到右下角的不同路径数。

这种方法的时间复杂度为O(m * n)，空间复杂度为O(m * n)。可以通过优化将空间复杂度降至O(n)。

#### 优化思路
由于每次计算`dp[i][j]`只需要上一行和当前行的数据，可以使用一维数组来优化空间复杂度。

#### 优化后的代码
```go
func uniquePaths(m int, n int) int {
    dp := make([]int, n)
    for j := 0; j < n; j++ {
        dp[j] = 1
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[j] += dp[j-1]
        }
    }
    return dp[n-1]
}
```

#### 优化代码解释
1. **初始化dp数组**：创建一个一维数组`dp`，并初始化为1。
2. **动态规划更新dp数组**：对于每一行，从左到右更新`dp[j]`为`dp[j] + dp[j-1]`。
3. **返回结果**：`dp[n-1]`即为从左上角到右下角的不同路径数。

优化后的空间复杂度为O(n)。



# 最小路径和

#### 方法思路
这个问题可以使用动态规划来解决。我们需要找到从网格的左上角到右下角的最小路径和，其中每次只能向右或向下移动。

1. **状态定义**：`dp[i][j]`表示到达网格第`i`行第`j`列的最小路径和。
2. **初始状态**：
   - `dp[0][0] = grid[0][0]`，因为起点就是左上角的格子。
   - 第一行的每个格子只能从左边过来，所以`dp[0][j] = dp[0][j-1] + grid[0][j]`。
   - 第一列的每个格子只能从上方过来，所以`dp[i][0] = dp[i-1][0] + grid[i][0]`。
3. **状态转移**：对于其他位置`(i, j)`，最小路径和等于上方和左方路径和中的较小值加上当前格子的值，即`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。
4. **结果获取**：`dp[m-1][n-1]`即为所求的最小路径和。

#### 解决代码
```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始化dp数组**：创建一个`m x n`的二维数组`dp`，并初始化起点、第一行和第一列的值。
2. **动态规划填充dp数组**：对于每个位置`(i, j)`，计算`dp[i][j]`为上方和左方路径和中的较小值加上当前格子的值。
3. **返回结果**：`dp[m-1][n-1]`即为从左上角到右下角的最小路径和。

这种方法的时间复杂度为O(m * n)，空间复杂度为O(m * n)。可以通过优化将空间复杂度降至O(n)。

#### 优化思路
由于每次计算`dp[i][j]`只需要上一行和当前行的数据，可以使用一维数组来优化空间复杂度。

#### 优化后的代码
```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([]int, n)
    dp[0] = grid[0][0]
    for j := 1; j < n; j++ {
        dp[j] = dp[j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        dp[0] += grid[i][0]
        for j := 1; j < n; j++ {
            dp[j] = min(dp[j], dp[j-1]) + grid[i][j]
        }
    }
    return dp[n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 优化代码解释
1. **初始化dp数组**：创建一个一维数组`dp`，并初始化第一行的值。
2. **动态规划更新dp数组**：对于每一行，从左到右更新`dp[j]`为上方和左方路径和中的较小值加上当前格子的值。
3. **返回结果**：`dp[n-1]`即为从左上角到右下角的最小路径和。

优化后的空间复杂度为O(n)。



# 最长回文子串

#### 方法思路
这个问题可以使用动态规划来解决。回文串是指正读和反读都相同的字符串。我们需要找到字符串`s`中的最长回文子串。

1. **状态定义**：`dp[i][j]`表示字符串`s`从第`i`个字符到第`j`个字符是否为回文子串。
2. **初始状态**：
   - 单个字符一定是回文，即`dp[i][i] = true`。
   - 两个相邻且相同的字符也是回文，即`dp[i][i+1] = (s[i] == s[i+1])`。
3. **状态转移**：对于长度大于2的子串，`dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]`。
4. **结果获取**：在填充`dp`数组的过程中，记录最长的回文子串的起始位置和长度。

#### 解决代码
```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
        dp[i][i] = true
    }
    start, maxLen := 0, 1
    for j := 1; j < n; j++ {
        for i := 0; i < j; i++ {
            if s[i] == s[j] {
                if j - i < 3 {
                    dp[i][j] = true
                } else {
                    dp[i][j] = dp[i+1][j-1]
                }
            } else {
                dp[i][j] = false
            }
            if dp[i][j] && j - i + 1 > maxLen {
                maxLen = j - i + 1
                start = i
            }
        }
    }
    return s[start:start+maxLen]
}
```

#### 代码解释
1. **初始化dp数组**：创建一个`n x n`的二维数组`dp`，并初始化单个字符为回文。
2. **动态规划填充dp数组**：对于每个子串`s[i..j]`，根据字符是否相等和内部子串是否为回文来更新`dp[i][j]`。
3. **记录最长回文子串**：在填充`dp`数组的过程中，记录最长回文子串的起始位置和长度。
4. **返回结果**：根据记录的起始位置和长度返回最长回文子串。

这种方法的时间复杂度为O(n^2)，空间复杂度为O(n^2)。可以通过中心扩展法进一步优化空间复杂度至O(1)。

#### 优化思路
中心扩展法利用回文串的中心对称性质，从每个可能的中心向两边扩展，寻找最长的回文子串。

#### 优化后的代码
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start, end := 0, 0
    for i := 0; i < len(s); i++ {
        len1 := expandAroundCenter(s, i, i)
        len2 := expandAroundCenter(s, i, i+1)
        maxLen := max(len1, len2)
        if maxLen > end - start {
            start = i - (maxLen - 1) / 2
            end = i + maxLen / 2
        }
    }
    return s[start:end+1]
}

func expandAroundCenter(s string, left, right int) int {
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return right - left - 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 优化代码解释
1. **中心扩展函数**：`expandAroundCenter`函数从给定的左右中心向两边扩展，返回回文子串的长度。
2. **遍历所有中心**：对于每个字符和每对相邻字符，作为中心进行扩展，寻找最长回文子串。
3. **更新最长子串**：根据扩展得到的回文子串长度，更新最长子串的起始和结束位置。
4. **返回结果**：根据记录的起始和结束位置返回最长回文子串。

优化后的空间复杂度为O(1)，适用于大规模输入。



# 最长公共子序列

#### 方法思路
这个问题可以使用动态规划来解决。我们需要找到两个字符串`text1`和`text2`的最长公共子序列的长度。关键在于定义状态和状态转移方程。

1. **状态定义**：`dp[i][j]`表示`text1`的前`i`个字符和`text2`的前`j`个字符的最长公共子序列的长度。
2. **初始状态**：`dp[0][j] = 0`和`dp[i][0] = 0`，表示一个空字符串与任何字符串的最长公共子序列长度为0。
3. **状态转移**：
   - 如果`text1[i-1] == text2[j-1]`，则`dp[i][j] = dp[i-1][j-1] + 1`。
   - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
4. **结果获取**：`dp[len(text1)][len(text2)]`即为所求。

#### 解决代码
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 代码解释
1. **初始化dp数组**：创建一个`(m+1) x (n+1)`的二维数组`dp`，并初始化为0。
2. **动态规划填充dp数组**：
   - 如果当前字符相等，则`dp[i][j]`等于左上角的值加1。
   - 否则，`dp[i][j]`等于上方或左方的较大值。
3. **返回结果**：`dp[m][n]`即为两个字符串的最长公共子序列的长度。

这种方法的时间复杂度为O(m * n)，空间复杂度为O(m * n)。可以通过优化将空间复杂度降至O(n)。

#### 优化思路
由于每次计算`dp[i][j]`只需要上一行和当前行的数据，可以使用一维数组来优化空间复杂度。

#### 优化后的代码
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([]int, n+1)
    for i := 1; i <= m; i++ {
        prev := 0
        for j := 1; j <= n; j++ {
            temp := dp[j]
            if text1[i-1] == text2[j-1] {
                dp[j] = prev + 1
            } else {
                dp[j] = max(dp[j], dp[j-1])
            }
            prev = temp
        }
    }
    return dp[n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 优化代码解释
1. **初始化dp数组**：创建一个一维数组`dp`，大小为`n+1`，初始化为0。
2. **动态规划更新dp数组**：
   - 使用`prev`变量保存`dp[i-1][j-1]`的值。
   - 如果当前字符相等，则`dp[j] = prev + 1`。
   - 否则，`dp[j]`等于上方或左方的较大值。
3. **返回结果**：`dp[n]`即为两个字符串的最长公共子序列的长度。

优化后的空间复杂度为O(n)。



# 编辑距离

#### 方法思路
这个问题可以使用动态规划来解决。我们需要计算将一个字符串`word1`转换为另一个字符串`word2`所需的最少操作次数，操作包括插入、删除和替换字符。

1. **状态定义**：`dp[i][j]`表示将`word1`的前`i`个字符转换为`word2`的前`j`个字符所需的最少操作次数。
2. **初始状态**：
   - `dp[0][j] = j`，表示将空字符串转换为`word2`的前`j`个字符需要`j`次插入操作。
   - `dp[i][0] = i`，表示将`word1`的前`i`个字符转换为空字符串需要`i`次删除操作。
3. **状态转移**：
   - 如果`word1[i-1] == word2[j-1]`，则`dp[i][j] = dp[i-1][j-1]`，无需操作。
   - 否则，`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`，分别对应删除、插入和替换操作。
4. **结果获取**：`dp[len(word1)][len(word2)]`即为所求。

#### 解决代码
```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 0; i <= m; i++ {
        dp[i][0] = i
    }
    for j := 0; j <= n; j++ {
        dp[0][j] = j
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1
            }
        }
    }
    return dp[m][n]
}

func min(a, b, c int) int {
    if a < b {
        if a < c {
            return a
        }
        return c
    }
    if b < c {
        return b
    }
    return c
}
```

#### 代码解释
1. **初始化dp数组**：创建一个`(m+1) x (n+1)`的二维数组`dp`，并初始化第一行和第一列。
2. **动态规划填充dp数组**：
   - 如果当前字符相等，则`dp[i][j]`等于左上角的值。
   - 否则，`dp[i][j]`等于上方、左方或左上角的最小值加1。
3. **返回结果**：`dp[m][n]`即为将`word1`转换为`word2`所需的最少操作次数。

这种方法的时间复杂度为O(m * n)，空间复杂度为O(m * n)。可以通过优化将空间复杂度降至O(n)。

#### 优化思路
由于每次计算`dp[i][j]`只需要上一行和当前行的数据，可以使用一维数组来优化空间复杂度。

#### 优化后的代码
```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([]int, n+1)
    for j := 0; j <= n; j++ {
        dp[j] = j
    }
    for i := 1; i <= m; i++ {
        prev := dp[0]
        dp[0] = i
        for j := 1; j <= n; j++ {
            temp := dp[j]
            if word1[i-1] == word2[j-1] {
                dp[j] = prev
            } else {
                dp[j] = min(dp[j], dp[j-1], prev) + 1
            }
            prev = temp
        }
    }
    return dp[n]
}

func min(a, b, c int) int {
    if a < b {
        if a < c {
            return a
        }
        return c
    }
    if b < c {
        return b
    }
    return c
}
```

#### 优化代码解释
1. **初始化dp数组**：创建一个一维数组`dp`，大小为`n+1`，并初始化为`0`到`n`。
2. **动态规划更新dp数组**：
   - 使用`prev`变量保存`dp[i-1][j-1]`的值。
   - 如果当前字符相等，则`dp[j] = prev`。
   - 否则，`dp[j]`等于上方、左方或左上角的最小值加1。
3. **返回结果**：`dp[n]`即为将`word1`转换为`word2`所需的最少操作次数。

优化后的空间复杂度为O(n)。