# 全排列

1. **初始化结果集**：用于存储所有可能的排列。
2. **回溯函数**：
   - **终止条件**：当当前排列的长度等于原数组长度时，将当前排列加入结果集。
   - **遍历选择**：从当前位置开始，依次将每个元素交换到当前位置，递归处理下一个位置。
   - **回溯撤销**：恢复数组状态，以便尝试其他选择。
3. **启动回溯**：从第一个位置开始调用回溯函数。

```go
func permute(nums []int) [][]int {
    var res [][]int
    backtrack(nums, 0, &res)
    return res
}

func backtrack(nums []int, start int, res *[][]int) {
    // 当 start 等于数组长度时，说明已经处理完所有元素，当前排列完成
    if start == len(nums) {
        // 复制当前排列到结果集中
        tmp := make([]int, len(nums))
        copy(tmp, nums)//传进来的先连接上，之后的在下面递归进去，在子函数中再连接上去
        *res = append(*res, tmp)
        return
    }

    // 从 start 开始，逐个将元素交换到 start 位置
    for i := start; i < len(nums); i++ {
        // 交换元素，生成新的排列
        nums[start], nums[i] = nums[i], nums[start]
        // 递归处理下一个位置
        backtrack(nums, start+1, res)
        // 撤销交换，回溯到上一步状态
        nums[start], nums[i] = nums[i], nums[start]
    }
}
```

# 子集

1. **初始化结果集**：用于存储所有可能的子集。
2. **回溯函数**：
   - **终止条件**：当处理完所有元素时，将当前子集加入结果集。
   - **选择当前元素**：递归调用，包含当前元素。
   - **不选择当前元素**：递归调用，不包含当前元素。
3. **启动回溯**：从第一个元素开始调用回溯函数。

```go
func subsets(nums []int) [][]int {
    var res [][]int
    backtrack(nums, 0, []int{}, &res)
    return res
}

func backtrack(nums []int, start int, path []int, res *[][]int) {
    // 将当前路径加入结果集
    tmp := make([]int, len(path))
    copy(tmp, path)//最开始调用的时候会把空的加进去
    *res = append(*res, tmp)

    // 从 start 开始逐个处理元素
    for i := start; i < len(nums); i++ {
        // 选择当前元素
        path = append(path, nums[i])//将每种组合的枚举列进去
        // 递归处理下一个元素
        backtrack(nums, i+1, path, res)
        // 回溯，撤销选择
        path = path[:len(path)-1]//回溯掉自己本身
    }
}
```

`path = path[:len(path)-1]`回溯掉这个的原因是，在递归的函数里面会把这个内容当作第一个写进path里面

# 电话号码的字母组合

1. **建立数字到字母的映射**：使用字典或数组存储每个数字对应的字母。
2. **初始化结果集**：用于存储所有可能的字母组合。
3. **回溯函数**：
   - **终止条件**：当当前组合长度等于输入数字字符串长度时，将组合加入结果集。
   - **遍历当前数字对应的字母**：递归调用，将字母加入当前组合。
4. **启动回溯**：从第一个数字开始调用回溯函数。

```go
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }

    digitToLetters := []string{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
    var res []string
    backtrack(digits, 0, "", digitToLetters, &res)
    return res
}

func backtrack(digits string, index int, path string, digitToLetters []string, res *[]string) {
    // 终止条件：当前路径长度等于数字字符串长度
    if len(path) == len(digits) {
        *res = append(*res, path)
        return
    }

    // 获取当前数字对应的字母
    letters := digitToLetters[digits[index]-'0']
    // 遍历当前数字对应的每个字母 枚举
    for i := 0; i < len(letters); i++ {
        // 选择当前字母，递归处理下一个数字
        backtrack(digits, index+1, path+string(letters[i]), digitToLetters, res)
    }
}
```

# 组合总和

1. **排序数组**：先对数组进行排序，方便后续剪枝处理。
2. **初始化结果集**：用于存储所有可能的组合。
3. **回溯函数**：
   - **终止条件**：当当前和等于 `target` 时，将当前组合加入结果集；当当前和超过 `target` 时，直接返回。
   - **遍历选择**：从当前位置开始，逐个选择元素，递归处理后续元素。
4. **启动回溯**：从第一个元素开始调用回溯函数。

```go
func combinationSum(candidates []int, target int) [][]int {
    var res [][]int
    sort.Ints(candidates)//对数组元素进行有序排列
    backtrack(candidates, target, 0, []int{}, &res)
    return res
}

func backtrack(candidates []int, target int, start int, path []int, res *[][]int) {
    // 终止条件：当前和等于 target
    if target == 0 {
        tmp := make([]int, len(path))
        copy(tmp, path)
        *res = append(*res, tmp)
        return
    }
    // 终止条件：当前和超过 target
    if target < 0 {
        return
    }

    // 从 start 开始逐个选择元素
    for i := start; i < len(candidates); i++ {
        // 选择当前元素
        path = append(path, candidates[i])
        // 递归处理，由于可以重复使用元素，所以从 i 开始
        backtrack(candidates, target-candidates[i], i, path, res)
        // 回溯，撤销选择
        path = path[:len(path)-1]
    }
}
```

# 括号生成

1. **初始化结果集**：用于存储所有有效的括号组合。
2. **回溯函数**：
   - **终止条件**：当当前组合长度等于 `2n` 时，将组合加入结果集。
   - **选择左括号**：如果左括号数量小于 `n`，可以添加左括号。
   - **选择右括号**：如果右括号数量小于左括号数量，可以添加右括号。
3. **启动回溯**：从空字符串开始调用回溯函数。

```go
func generateParenthesis(n int) []string {
    var res []string
    backtrack(n, 0, 0, "", &res)
    return res
}

func backtrack(n int, left int, right int, path string, res *[]string) {
    // 终止条件：当前组合长度等于 2n
    if len(path) == 2*n {
        *res = append(*res, path)
        return
    }

    // 选择左括号
    if left < n {
        backtrack(n, left+1, right, path+"(", res)
    }
    // 选择右括号
    if right < left {
        backtrack(n, left, right+1, path+")", res)
    }
}
```

# 单词搜索

1. **遍历网格**：从网格的每一个单元格开始，尝试匹配单词的第一个字符。
2. **DFS搜索**：对于每一个匹配的起始位置，使用DFS向四个方向（上、下、左、右）递归搜索下一个字符。
3. **标记访问**：为了避免重复使用同一个单元格，需要在访问时临时标记该单元格为已访问，搜索完成后恢复其原始值。
4. **终止条件**：如果所有字符都匹配成功，返回true；否则，返回false。

```go
// 主函数：判断单词是否存在于二维网格中
func exist(board [][]byte, word string) bool {
    // 获取网格的行数 m 和列数 n
    m, n := len(board), len(board[0])
    
    // 遍历网格中的每一个单元格
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            // 以当前单元格为起点，进行深度优先搜索
            if dfs(board, word, i, j, 0) {
                return true // 如果找到单词，立即返回 true
            }
        }
    }
    // 遍历完所有单元格仍未找到，返回 false
    return false
}

// 深度优先搜索（DFS）辅助函数
// board: 二维网格
// word: 要搜索的单词
// i, j: 当前网格的行列索引
// k: 当前匹配到单词的第 k 个字符
func dfs(board [][]byte, word string, i, j, k int) bool {
    // 终止条件1：已匹配完单词的所有字符
    if k == len(word) {
        return true
    }
    
    // 终止条件2：当前索引越界 或 当前字符不匹配
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] != word[k] {
        return false
    }
    
    // 临时保存当前字符，并标记为已访问（用 '#' 占位）
    tmp := board[i][j]
    board[i][j] = '#'
    
    // 向四个方向递归搜索（下、上、右、左）
    res := dfs(board, word, i+1, j, k+1) || // 向下搜索
           dfs(board, word, i-1, j, k+1) || // 向上搜索
           dfs(board, word, i, j+1, k+1) || // 向右搜索
           dfs(board, word, i, j-1, k+1)    // 向左搜索
    
    // 恢复当前字符（回溯）
    board[i][j] = tmp//恢复原图
    
    // 返回搜索结果
    return res
}
```

# 分割回文串

1. **初始化结果集**：用于存储所有有效的分割方案。
2. **回溯函数**：
   - **终止条件**：当处理完整个字符串时，将当前分割方案加入结果集。
   - **遍历分割点**：从当前位置开始，逐个检查可能的子串是否为回文。
   - **递归处理**：如果子串是回文，则递归处理剩余字符串。
3. **启动回溯**：从字符串的起始位置开始调用回溯函数。

```go
func partition(s string) [][]string {
    var res [][]string
    backtrack(s, 0, []string{}, &res)
    return res
}

func backtrack(s string, start int, path []string, res *[][]string) {
    // 终止条件：处理完整个字符串
    if start == len(s) {
        tmp := make([]string, len(path))
        copy(tmp, path)
        *res = append(*res, tmp)
        return
    }

    // 遍历所有可能的分割点
    for i := start; i < len(s); i++ {
        // 检查当前子串是否是回文
        if isPalindrome(s, start, i) {
            // 选择当前子串，递归处理剩余字符串
            path = append(path, s[start:i+1])
            backtrack(s, i+1, path, res)
            // 回溯，撤销选择
            path = path[:len(path)-1]
        }
    }
}

// 检查子串 s[left..right] 是否是回文
func isPalindrome(s string, left, right int) bool {
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

# N 皇后（难）