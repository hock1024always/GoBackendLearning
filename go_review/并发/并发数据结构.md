# Channel

## channel类型

1. **阻塞规则**：
   - 无缓冲：发送/接收必须同时就绪
   - 有缓冲：发送仅当缓冲区满时阻塞，接收仅当缓冲区空时阻塞
   - `nil` 通道：所有操作永久阻塞
2. **关闭通道**：
   - 只有发送者能关闭通道
   - 重复关闭会 panic
   - 关闭后接收方会收到零值 + `false`
3. **通道比较**：
   - 通道只能用 `==` 比较是否为同一个通道（或是否为 `nil`）

### 按通信方向分类

| 类型           | 语法       | 说明                                                   |
| :------------- | :--------- | :----------------------------------------------------- |
| **双向通道**   | `chan T`   | 默认类型，既可发送数据也可接收数据                     |
| **只发送通道** | `chan<- T` | 只能发送数据到通道（通常用于函数参数限制调用方行为）   |
| **只接收通道** | `<-chan T` | 只能从通道接收数据（常用于安全暴露通道给外部只读访问） |

```go
func Communication() {
	//可读可写的通道
	ch := make(chan int)
	go communicationF1(ch)
	go communicationF2(ch)
}

// F1接收一个只写通道
func communicationF1(ch chan<- int) {
	//通过循环向通道写入0-99
	for i := 0; i < 10; i++ {
		ch <- i
	}
}

// F2接收一个只读通道
func communicationF2(ch <-chan int) {
	for i := range ch {
		fmt.Println(i)
	}
}
```

### **按缓冲区分类**

| 类型           | 创建方式             | 行为特点                                                     |
| :------------- | :------------------- | :----------------------------------------------------------- |
| **无缓冲通道** | `make(chan T)`       | 同步通信，发送和接收操作会阻塞，直到另一端准备好（直接耦合发送和接收方） |
| **有缓冲通道** | `make(chan T, size)` | 异步通信，缓冲区未满时发送不阻塞，缓冲区非空时接收不阻塞     |

```go
// 无缓冲通道（同步）
ch1 := make(chan int)
go func() { 
  	ch1 <- 1 
}()  // 阻塞直到有人接收
val := <-ch1

// 有缓冲通道（异步）
ch2 := make(chan int, 3)
ch2 <- 1  // 立即完成（缓冲区未满）
ch2 <- 2
fmt.Println(<-ch2)  // 1
```

### **按元素类型分类**

| 类型             | 示例               | 说明                                 |
| :--------------- | :----------------- | :----------------------------------- |
| **普通类型通道** | `chan int`         | 传输基本类型或结构体等具体类型       |
| **空接口通道**   | `chan interface{}` | 可传输任意类型（需类型断言）         |
| **通道的通道**   | `chan chan string` | 传输通道类型本身（用于高级通信模式） |

```go
// 空接口通道
anyCh := make(chan interface{})
anyCh <- "hello"
anyCh <- 42
val := <-anyCh.(string)  // 需要类型断言

// 通道的通道
cmdCh := make(chan chan string)
respCh := make(chan string)
cmdCh <- respCh  // 发送一个通道
replyCh := <-cmdCh  // 接收一个通道
```

### **特殊通道类型**

| 类型           | 说明                                                         |
| :------------- | :----------------------------------------------------------- |
| **`nil` 通道** | 未初始化的通道（`var ch chan int`），发送/接收会永久阻塞     |
| **已关闭通道** | 关闭后仍可接收剩余数据，但发送会 panic；接收操作返回零值和 `false` |

```go
var nilCh chan int  // nil通道
// nilCh <- 1      // 永久阻塞

closedCh := make(chan int, 2)
closedCh <- 1
close(closedCh)
v, ok := <-closedCh  // v=1, ok=true
v, ok = <-closedCh   // v=0, ok=false（通道已空且关闭）
```

### 按底层实现分类

| 类型              | 说明                                     |
| :---------------- | :--------------------------------------- |
| **普通通道**      | 默认实现，基于环形缓冲区                 |
| **单向通道**      | 编译时约束，运行时仍是双向通道           |
| **`select` 专用** | 在 `select` 语句中使用的通道会有特殊优化 |

## channel的使用

### 读写

```go
// 并发场景下的同步机制
func ConcurrentSync() {
	ch := make(chan int, 10)

	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()
	go func() {
		for i := range ch {
			fmt.Println(i)
		}
	}()
}
```

### 多通道的读写

```go
// 通知协程退出与多路复用
func NotifyAndMultiplex() {
	ch := make(chan int, 10)
	strCh := make(chan string, 10)
	done := make(chan struct{})//空结构体类型，占用空间最少，仅作为事件通知的载体

	go noticeAndMultiplexingF1(ch)
	go noticeAndMultiplexingF2(strCh)
	go noticeAndMultiplexingF3(ch, strCh, done)

	time.Sleep(1 * time.Second) // 等待任务完成（生产环境应用 sync.WaitGroup）
	close(done)
}

func noticeAndMultiplexingF1(ch chan<- int) {
	for i := 0; i < 10; i++ {
		ch <- i
	}

}

func noticeAndMultiplexingF2(ch chan<- string) {
	for i := 0; i < 10; i++ {
		ch <- fmt.Sprintf("hello %d", i)
	}

}

func noticeAndMultiplexingF3(ch <-chan int, strCh <-chan string, done <-chan struct{}) {
	i := 0
	for {
		select {
		case num, ok := <-ch:
			if !ok { // ch 已关闭
				ch = nil // 将 ch 设为 nil，该 case 将永远阻塞（select 会忽略 nil 通道）
				continue
			}
			fmt.Println(num)
		case str, ok := <-strCh:
			if !ok { // strCh 已关闭
				strCh = nil
				continue
			}
			fmt.Println(str)
		case <-done:
			fmt.Println("收到退出通知")
			return
		}
		i++
		fmt.Println("累计执行次数：", i)
	}
	fmt.Println("结束")
}
```



