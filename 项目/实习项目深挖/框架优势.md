# 一、推送系统设计（Push System）

### 解决的问题：

1. **双向实时通信**：支持服务器主动推送和设备状态上报

2. **多种推送模式**：

   ```go
   // 单播推送
   WebSocketSuccess(conn, requestId, service, message)
   
   // 广播推送  
   WebSocketPush(clients, service, message)
   
   // 条件推送
   BroadcastToUser(username, message)
   ```

3. **推送可靠性**：

   - 非阻塞发送防止单点故障
   - 错误重试和日志记录
   - 连接状态监控

# 二、设备监测体系（Device Monitoring）

### 架构特点：

1. **统一设备模型**：

   ```go
   type Device struct {
       SN         string    // 设备序列号
       Type       string    // 设备类型
       Status     int       // 在线状态
       // 丰富的状态字段...
   }
   ```

2. **多维状态监控**：

   - 定位状态（LocationCode, LocationMsg）
   - 巡检状态（InspectionCode, InspectionMsg） 
   - 垃圾检测状态（RubbishCode, RubbishMsg）
   - 电量状态（ElectricityCode, ElectricityMsg）

3. **历史状态追踪**：

   ```go
   type DeviceStatus struct {
       DeviceID uint   // 关联设备
       // 各种状态记录...
   }
   ```

# 三、WebSocket Service拆分设计

### 创新性的路由架构：

1. **统一路由注册**：

   ```go
   // rules.go 中集中注册
   ServerRules["/api/user/login"] = dog.Login
   ServerRules["/admin/auth/login"] = admin.Login
   ```

2. **Service-Based架构**：

   - 每个API对应一个service path
   - 自动路由到对应的handler方法
   - 统一的请求/响应格式

3. **上下文管理**：

   ```go
   type ServerContext struct {
       Conn     *websocket.Conn
       Message  *model.RequestMessage  // 请求消息
       clients  *sync.Map              // 连接池
       UserInfo *model.UserSession     // 用户会话
   }
   ```

# 四、客户端连接数据结构设计

### 多层连接管理：

1. **连接池设计**：

   ```go
   // 使用sync.Map管理所有连接
   Clients *sync.Map  // key: clientId, value: *websocket.Conn
   ```

2. **会话管理**：

   ```go
   type UserSession struct {
       UserID   string
       Username string
   }
   
   // 连接与用户绑定
   ctx.clients.Store(ctx.Conn, session.UserID)
   ```

3. **状态维护**：

   - 认证状态管理
   - 连接生命周期管理
   - 用户权限控制

# 五、核心优势总结

### 1. 高性能并发处理

```go
// 使用sync.Map实现线程安全的连接管理
clients *sync.Map

// 读写锁优化
mu sync.RWMutex
```

### 2. 完善的错误处理

```go
// 统一错误响应格式
WebSocketFailure(conn, requestId, service, err, code)

// panic恢复机制
defer func() {
    if r := recover(); r != nil {
        // 记录stack trace
    }
}()
```

### 3. 灵活的扩展性

```go
// 易于添加新的service
ServerRules["/new/service"] = newHandler

// 支持多种设备类型
deviceTypes := []string{"retail", "dance_robot", "dance_dog", "rubbish"}
```

### 4. 安全认证机制

```go
// Token验证
ValidateToken(sn, timestamp, token)

// 用户会话管理
SetUserSession(session)
IsAuthenticated()
```

# 六、典型工作流程

1. **连接建立**：设备通过WebSocket连接服务器
2. **认证登录**：调用`/api/user/login`进行认证
3. **状态上报**：设备定期上报状态信息
4. **监控推送**：服务器向管理端推送设备状态
5. **命令下发**：管理端向设备发送控制指令

# 七、设计亮点

## 1. 双向实时通信实现

### 底层通信机制

```go
// 使用gorilla/websocket库建立双向通信
var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool { return true },
}

// 连接升级为WebSocket
func HandlerWebsocket(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        return
    }
    defer conn.Close()
    
    // 启动读协程（接收设备消息）
    go readPump(conn)
    // 启动写协程（发送服务器消息）
    go writePump(conn)
}
```

### 设备状态上报处理

```go
// 读协程 - 处理设备上报的消息
func readPump(conn *websocket.Conn) {
    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            break
        }
        
        // 解析消息协议
        var msg model.RequestMessage
        if err := json.Unmarshal(message, &msg); err != nil {
            continue
        }
        
        // 路由到对应的service处理
        if handler, exists := rules.ServerRules[msg.Service]; exists {
            ctx := context.NewServerContext(conn, &msg, clients, nil)
            go handler(ctx) // 异步处理
        }
    }
}
```

### 服务器主动推送

```go
// 写协程 - 处理服务器发往设备的消息
func writePump(conn *websocket.Conn) {
    sendChan := make(chan []byte, 100) // 带缓冲的发送通道
    
    for {
        select {
        case message := <-sendChan:
            if err := conn.WriteMessage(websocket.TextMessage, message); err != nil {
                return // 连接异常，退出协程
            }
        case <-time.After(30 * time.Second):
            // 发送心跳保持连接
            conn.WriteMessage(websocket.PingMessage, nil)
        }
    }
}
```

## 2. 多种推送模式实现

### 单播推送实现

```go
// WebSocketSuccess 单播推送（响应式）
func WebSocketSuccess(conn *websocket.Conn, requestId any, service string, message any) error {
    response := map[string]any{
        "op":         "galbot_response",
        "service":    service,
        "code":       0,
        "msg":        "",
        "values":     message,
        "result":     true,
        "request_id": requestId, // 关联请求ID
    }
    
    return sendMessage(conn, response)
}

// 底层发送实现
func sendMessage(conn *websocket.Conn, data map[string]any) error {
    msgBytes, err := json.Marshal(data)
    if err != nil {
        return err
    }
    
    // 设置写超时防止阻塞
    conn.SetWriteDeadline(time.Now().Add(5 * time.Second))
    return conn.WriteMessage(websocket.TextMessage, msgBytes)
}
```

### 广播推送实现

```go
// WebSocketPush 广播推送（并发发送）
func WebSocketPush(clients []*websocket.Conn, service string, message any, requestId ...string) []error {
    // 生成唯一请求ID
    reqID := generateRequestID()
    if len(requestId) > 0 {
        reqID = requestId[0]
    }
    
    response := map[string]any{
        "op":         "galbot_push",
        "service":    service,
        "code":       0,
        "msg":        "",
        "values":     message,
        "result":     true,
        "request_id": reqID,
    }
    
    // 并发发送给所有客户端
    var wg sync.WaitGroup
    errChan := make(chan error, len(clients))
    
    for _, client := range clients {
        wg.Add(1)
        go func(conn *websocket.Conn) {
            defer wg.Done()
            if err := sendMessage(conn, response); err != nil {
                errChan <- err
            }
        }(client)
    }
    
    wg.Wait()
    close(errChan)
    
    // 收集错误
    var errs []error
    for err := range errChan {
        errs = append(errs, err)
    }
    
    return errs
}
```

### 条件推送实现

```go
// BroadcastToUser 按用户条件推送
func (ctx *ServerContext) BroadcastToUser(username string, message interface{}) error {
    var errs []error
    var targetClients []*websocket.Conn

    // 第一步：找出目标客户端（减少锁持有时间）
    ctx.clients.Range(func(key, value interface{}) bool {
        if session, ok := value.(*model.UserSession); ok && session.Username == username {
            if conn, ok := key.(*websocket.Conn); ok {
                targetClients = append(targetClients, conn)
            }
        }
        return true
    })

    // 第二步：批量推送
    errors := utils.WebSocketPush(targetClients, "user_broadcast", message)
    if len(errors) > 0 {
        return fmt.Errorf("broadcast errors: %v", errors)
    }
    
    return nil
}

// 更高级的条件推送示例
func BroadcastByCondition(condition func(session *model.UserSession) bool, message interface{}) error {
    var targetClients []*websocket.Conn
    
    clients.Range(func(conn, session interface{}) bool {
        if userSession, ok := session.(*model.UserSession); ok {
            if condition(userSession) {
                targetClients = append(targetClients, conn.(*websocket.Conn))
            }
        }
        return true
    })
    
    return utils.WebSocketPush(targetClients, "conditional_broadcast", message)
}
```

## 3. 推送可靠性保障

### 非阻塞发送实现

```go
// 带超时的非阻塞发送
func sendWithTimeout(conn *websocket.Conn, message []byte, timeout time.Duration) error {
    done := make(chan error, 1)
    
    go func() {
        conn.SetWriteDeadline(time.Now().Add(timeout))
        done <- conn.WriteMessage(websocket.TextMessage, message)
    }()
    
    select {
    case err := <-done:
        return err
    case <-time.After(timeout):
        return fmt.Errorf("send timeout after %v", timeout)
    }
}

// 带缓冲的异步发送
type AsyncSender struct {
    sendChan chan asyncMessage
    bufferSize int
}

type asyncMessage struct {
    conn    *websocket.Conn
    message []byte
}

func NewAsyncSender(bufferSize int) *AsyncSender {
    sender := &AsyncSender{
        sendChan: make(chan asyncMessage, bufferSize),
    }
    go sender.processQueue()
    return sender
}

func (s *AsyncSender) SendAsync(conn *websocket.Conn, message []byte) bool {
    select {
    case s.sendChan <- asyncMessage{conn, message}:
        return true
    default:
        // 缓冲区满，丢弃消息并记录日志
        log.Warn("Send buffer full, message dropped")
        return false
    }
}

func (s *AsyncSender) processQueue() {
    for msg := range s.sendChan {
        if err := sendWithTimeout(msg.conn, msg.message, 3*time.Second); err != nil {
            log.Errorf("Async send failed: %v", err)
            // 这里可以加入重试逻辑
        }
    }
}
```

### 错误重试机制

```go
// 带重试的发送
func sendWithRetry(conn *websocket.Conn, message []byte, maxRetries int) error {
    var lastErr error
    
    for i := 0; i < maxRetries; i++ {
        if err := sendWithTimeout(conn, message, 3*time.Second); err != nil {
            lastErr = err
            log.Warnf("Send attempt %d failed: %v", i+1, err)
            
            // 指数退避
            backoff := time.Duration(math.Pow(2, float64(i))) * time.Second
            time.Sleep(backoff)
            continue
        }
        return nil
    }
    
    return fmt.Errorf("send failed after %d retries: %v", maxRetries, lastErr)
}

// 连接状态检查重试
func ensureConnectedSend(conn *websocket.Conn, message []byte) error {
    // 检查连接状态
    if !isConnectionAlive(conn) {
        return fmt.Errorf("connection is not alive")
    }
    
    return sendWithRetry(conn, message, 3)
}
```

### 连接状态监控

```go
// 连接健康检查
type ConnectionMonitor struct {
    connections    *sync.Map
    checkInterval  time.Duration
    timeout        time.Duration
}

func NewConnectionMonitor(checkInterval, timeout time.Duration) *ConnectionMonitor {
    monitor := &ConnectionMonitor{
        connections:   &sync.Map{},
        checkInterval: checkInterval,
        timeout:       timeout,
    }
    go monitor.startMonitoring()
    return monitor
}

func (m *ConnectionMonitor) startMonitoring() {
    ticker := time.NewTicker(m.checkInterval)
    for range ticker.C {
        m.checkConnections()
    }
}

func (m *ConnectionMonitor) checkConnections() {
    m.connections.Range(func(key, value interface{}) bool {
        conn := key.(*websocket.Conn)
        
        // 发送ping检查连接
        if err := conn.WriteControl(websocket.PingMessage, nil, time.Now().Add(m.timeout)); err != nil {
            log.Warnf("Connection %s is dead, removing", conn.RemoteAddr())
            m.connections.Delete(key)
            conn.Close()
        }
        return true
    })
}

// 连接活性追踪
func trackConnectionActivity(conn *websocket.Conn) {
    conn.SetPongHandler(func(string) error {
        // 更新最后活跃时间
        updateLastActive(conn, time.Now())
        return nil
    })
}
```

### 完整的推送服务示例

```go
type PushService struct {
    asyncSender    *AsyncSender
    connectionMon  *ConnectionMonitor
    retryQueue     *RetryQueue
}

func NewPushService() *PushService {
    service := &PushService{
        asyncSender:   NewAsyncSender(1000),
        connectionMon: NewConnectionMonitor(30*time.Second, 5*time.Second),
        retryQueue:    NewRetryQueue(),
    }
    return service
}

func (s *PushService) PushToClient(conn *websocket.Conn, message interface{}) error {
    messageBytes, err := json.Marshal(message)
    if err != nil {
        return err
    }
    
    // 异步发送（非阻塞）
    if !s.asyncSender.SendAsync(conn, messageBytes) {
        // 进入重试队列
        s.retryQueue.Add(conn, messageBytes)
    }
    
    return nil
}

// 重试队列实现
type RetryQueue struct {
    queue   *list.List
    mu      sync.Mutex
}

func (q *RetryQueue) Add(conn *websocket.Conn, message []byte) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    q.queue.PushBack(retryItem{conn, message, time.Now(), 0})
}

func (q *RetryQueue) Process() {
    for {
        time.Sleep(10 * time.Second)
        
        q.mu.Lock()
        for e := q.queue.Front(); e != nil; e = e.Next() {
            item := e.Value.(retryItem)
            if time.Since(item.timestamp) > time.Duration(item.retryCount+1)*30*time.Second {
                if q.retrySend(item) {
                    q.queue.Remove(e)
                } else {
                    item.retryCount++
                }
            }
        }
        q.mu.Unlock()
    }
}
```

## 4. 监控和日志体系

```go
// 推送指标监控
var (
    pushSuccessCount = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "push_success_total",
            Help: "Total successful pushes",
        },
        []string{"service"},
    )
    
    pushFailureCount = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "push_failure_total", 
            Help: "Total failed pushes",
        },
        []string{"service", "error_type"},
    )
    
    pushLatency = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "push_latency_seconds",
            Help:    "Push latency distribution",
            Buckets: prometheus.ExponentialBuckets(0.001, 2, 10),
        },
        []string{"service"},
    )
)

// 详细日志记录
func logPushAttempt(conn *websocket.Conn, service string, start time.Time, err error) {
    latency := time.Since(start)
    remoteAddr := conn.RemoteAddr().String()
    
    if err != nil {
        log.WithFields(log.Fields{
            "service":    service,
            "latency":    latency,
            "remote_addr": remoteAddr,
            "error":      err.Error(),
        }).Warn("Push failed")
        
        pushFailureCount.WithLabelValues(service, getErrorType(err)).Inc()
    } else {
        log.WithFields(log.Fields{
            "service":    service,
            "latency":    latency,
            "remote_addr": remoteAddr,
        }).Info("Push succeeded")
        
        pushSuccessCount.WithLabelValues(service).Inc()
    }
    
    pushLatency.WithLabelValues(service).Observe(latency.Seconds())
}
```

这样的设计确保了推送系统的高可用性、可靠性和性能，能够应对大规模并发的实时通信需求。