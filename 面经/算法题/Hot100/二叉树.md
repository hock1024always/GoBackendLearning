# 二叉树的中序遍历

## 解题代码

### 递归法

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    //使用递归法来解决
    var result []int 
    inorder(root,&result)
    return result
}

func inorder(root *TreeNode , result *[]int){
    //判断该节点是否为nil
    if(root == nil){
        return
    }

    //中序遍历在代码中的体现就是递归代码中放中间
    inorder(root.Left,result)
    *result = append(*result,root.Val)
    inorder(root.Right,result)
}
```

更好的写法是下面的root换成node

### 使用栈的迭代法

```GO
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    var result []int
    stack := []*TreeNode{}
    current := root

    for current != nil || len(stack) > 0 {
        // 遍历到最左节点，沿途压栈
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }
        // 弹出栈顶元素
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, current.Val)
        // 转向右子树
        current = current.Right
    }
    return result
}
```

## 语法点回顾

### 递归的前中后序遍历

1. 前中后序遍历在代码中就是操作语句放在左右节点的同名函数前、中还是后

### 栈的使用

1. 首先使用的是数组去模拟栈的实现，在切片中采用了`current = stack[len(stack)-1]  stack = stack[:len(stack)-1]`这样的写法来将一个切片作为栈来使用
2. 将左节点放入栈中，本质上就相当于是将左节点进行递归操作

# 二叉树的最大深度

## 解题方法

### 方法一：递归法（DFS）

这是最直观的解决方法。二叉树的最大深度等于其左右子树的最大深度加1。

算法步骤：

1. 如果根节点为空，返回0
2. 递归计算左子树的最大深度
3. 递归计算右子树的最大深度
4. 返回左右子树最大深度中的较大值加1

```GO
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return max(leftDepth, rightDepth) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 方法二：迭代法（BFS）

使用层序遍历，每遍历一层，深度加1，直到遍历完所有层。

```GO
func maxDepth(root *TreeNode) int {
    depth := 0
    if root == nil{
        return 0
    }
    //定义队列
    queue := []*TreeNode{root}
    //遍历这个队列、直到队列为空
    for len(queue) > 0{
        levelSize := len(queue)
        //对整个层的节点都进行这个操作
        for i := 0; i < levelSize; i++{
            //出队
            node := queue[0]
            queue = queue[1:]
            //检查左右节点并且入队 
            if node.Left != nil{
                queue = append(queue , node.Left)
            }
            if node.Right != nil{
                queue = append(queue , node.Right)
            }
        } 
        depth++
    }
    return depth
}
```



在这个方法中，还是还很巧妙的使用了切片实现了简单的队列：

1. **队列的定义：** `queue := []*TreeNode{root}`
2. **出队操作：** `node := queue[0]    queue = queue[1:]`
3. **入队操作：** `queue = append(queue, node.Left)`

# 翻转二叉树

## 解题思路

### 方法一：递归法

最终呈现的效果是先去进行对每一个最小子树进行左右交换，之后对上一级子树进行直到到达根节点

这是最直观的解决方法：

1. 如果当前节点为空，直接返回
2. 递归翻转左子树
3. 递归翻转右子树
4. 交换当前节点的左右子树

```GO
func invertTree(root *TreeNode) *TreeNode {
    //终结条件：首先进行，判空返回
    if root == nil{
        return nil
    }

    //递归执行
    root.Left = invertTree(root.Left)
    root.Right = invertTree(root.Right)       

    //交换左右侧
    left := root.Right
    root.Right = root.Left
    root.Left = left
    

    return root
}
```

### 方法二：迭代法（BFS）

使用层序遍历，在遍历每个节点时交换其左右子节点。

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        
        // 交换左右子节点
        node.Left, node.Right = node.Right, node.Left
        
        // 将子节点加入队列
        if node.Left != nil {
            queue = append(queue, node.Left)
        }
        if node.Right != nil {
            queue = append(queue, node.Right)
        }
    }
    
    return root
}
```

# 对称二叉树

## 解题方法

### 方法一：递归

1. 定义辅助函数检查两棵树是否镜像对称
2. 比较根节点的左右子树是否互为镜像
3. 镜像条件：
   - 两个节点值相等
   - 左子树的左子树与右子树的右子树对称
   - 左子树的右子树与右子树的左子树对称

```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isMirror(root.Left, root.Right)
}

func isMirror(left, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }
    if left == nil || right == nil {
        return false
    }
    return left.Val == right.Val && 
           isMirror(left.Left, right.Right) && 
           isMirror(left.Right, right.Left)
}
```

下面这个返回值比较巧妙：

```go
return left.Val == right.Val && 
           isMirror(left.Left, right.Right) && 
           isMirror(left.Right, right.Left)
```

### 方法二：迭代法（队列）

使用队列来同时比较对称位置的节点

```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    
    queue := []*TreeNode{root.Left, root.Right}
    
    for len(queue) > 0 {
        left := queue[0]
        right := queue[1]
        queue = queue[2:]
        
        if left == nil && right == nil {
            continue
        }
        if left == nil || right == nil {
            return false
        }
        if left.Val != right.Val {
            return false
        }
        
        queue = append(queue, left.Left, right.Right)
        queue = append(queue, left.Right, right.Left)
    }
    
    return true
}
```

这个题目的递归就记住左节点的左子节点和右节点的右子节点进行比较

# 二叉树的直径

## 解题方法

### 递归计算高度

1. 对于每个节点，直径长度等于左子树高度 + 右子树高度
2. 我们需要在计算树高度的同时，记录最大直径
3. 使用一个全局变量来跟踪最大直径
4. 递归计算每个节点的高度（1 + max(左高度, 右高度)）

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func diameterOfBinaryTree(root *TreeNode) int {
    maxDiameter := 0
    var depth func(*TreeNode) int
    depth = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        leftDepth := depth(node.Left)
        rightDepth := depth(node.Right)
        // 更新最大直径
        maxDiameter = max(maxDiameter, leftDepth + rightDepth)
        // 返回当前节点的高度
        return max(leftDepth, rightDepth) + 1
    }
    depth(root)
    return maxDiameter
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

# 二叉树的层序遍历

```go
func levelOrder(root *TreeNode) [][]int {
    
    //首先对根节点进行判断
    if root == nil{
        return nil
    }
    
    //创建最终的返回值
    var result [][]int

    //创建一个队列
    queue := []*TreeNode{root}
    
    for len(queue)>0 {
        levelsize := len(queue)

        //录入该层的节点，以便后续拼接到结果数组里面
        currentLevel := make([]int, 0, levelsize)

        for i:= 0 ; i < levelsize ; i++{//直接遍历一层的节点
            //出队
            node := queue[0]
            queue = queue[1:]
            //处理当前层的写入
            currentLevel = append(currentLevel,node.Val)

            //操作下一层
            if node.Left != nil{
                queue = append(queue,node.Left)
            }  

            if node.Right != nil{
                queue = append(queue,node.Right)
            }
        }

        //将当前新层写入结果
        result = append(result,currentLevel)
    }

    return result
}
```

# 将有序数组转换为二叉搜索树

1. **选择中间元素**：每次递归调用时，找到当前子数组的中间元素作为根节点。
2. **递归构建子树**：左子树由中间元素左侧的子数组构建，右子树由中间元素右侧的子数组构建。
3. **终止条件**：当子数组为空时，返回`nil`。

```go
func sortedArrayToBST(nums []int) *TreeNode {
    //判空
    if len(nums) == 0 {
        return nil
    }
    //从中间放进去开始递归
    mid := len(nums) / 2
    root := &TreeNode{Val: nums[mid]}
    root.Left = sortedArrayToBST(nums[:mid])
    root.Right = sortedArrayToBST(nums[mid+1:])
    return root
}
```

1. ` mid := len(nums) / 2`  
2. **递归构建子树**：
   - 左子树由`nums`数组的前半部分（`nums[:mid]`）构建。
   - 右子树由`nums`数组的后半部分（`nums[mid+1:]`）构建。

# 验证二叉搜索树

这个程序设计的核心是维护一个范围，使用这个范围判断数是否在范围之内

1. **递归验证**：通过递归遍历每个节点，检查其值是否在允许的范围内。初始时，根节点的范围是负无穷到正无穷。
2. **更新范围**：对于左子树，当前节点的值成为新的上界；对于右子树，当前节点的值成为新的下界。
3. **终止条件**：如果节点为空，返回`true`；如果节点值不在当前范围内，返回`false`。

```go
func isValidBST(root *TreeNode) bool {
    return helper(root, nil, nil)
}

func helper(node *TreeNode, lower *int, upper *int) bool {
    if node == nil {
        return true
    }
    val := node.Val
    if lower != nil && val <= *lower {
        return false
    }
    if upper != nil && val >= *upper {
        return false
    }
    //满足：节点的左子树只包含 小于当前节点的数
    if !helper(node.Left, lower, &val) {
        return false
    }
    //满足：节点的右子树只包含 大于当前节点的数
    if !helper(node.Right, &val, upper) {
        return false
    }
    return true
}
```

# 二叉搜索树中第 K 小的元素

1. 二插搜索树有一个特性，**中序遍历**BST会得到一个升序排列的节点值序列
2. 因此，第k小的元素就是中序遍历序列中的第k个元素。

```go
func kthSmallest(root *TreeNode, k int) int {
    //中序遍历找到的第k个数字就是
    var count int
    var result int

    //进行中序遍历
    helper(root , &count , &result , k)
    return result
}

func helper(node *TreeNode , count *int , result *int , k int){
    //经典判空
    if(node == nil){
        return
    }
    //使用递归方法
    helper(node.Left,count,result,k)
    *count++
    if *count == k{
        *result = node.Val 
    }
    helper(node.Right,count,result,k)
}
```

下面这个更简洁

```go
func kthSmallest(root *TreeNode, k int) int {
    var result int
    var count int
    var inorder func(node *TreeNode)
    
    inorder = func(node *TreeNode) {
        if node == nil {
            return
        }
        inorder(node.Left)
        count++
        if count == k {
            result = node.Val
            return
        }
        inorder(node.Right)
    }
    
    inorder(root)
    return result
}
```

# 二叉树的右视图

使用广度优先搜索（BFS）进行层序遍历，并在每一层遍历时记录最后一个节点的值。

```go
func rightSideView(root *TreeNode) []int {
    //首先对根节点进行判断
    if root == nil{
        return nil
    }
    
    //存储最右侧节点是数组
    var result []int
    //使用队列进行层序遍历的操作
    queue := []*TreeNode{root}
    
    for len(queue)>0 {
        levelsize := len(queue)

        for i:= 0 ; i < levelsize ; i++{//直接遍历一层的节点
            //出队
            node := queue[0]
            queue = queue[1:]
            //处理当前层的写入
            if i == levelsize - 1{
                result = append(result,node.Val)
            }

            //操作下一层
            if node.Left != nil{
                queue = append(queue,node.Left)
            }  

            if node.Right != nil{
                queue = append(queue,node.Right)
            }
        }
    }

    return result
}
```

```go
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }
    
    var result []int
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        levelSize := len(queue)
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            
            if i == levelSize - 1 {
                result = append(result, node.Val)
            }
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    
    return result
}
```

# 二叉树展开为链表

相当于是使用后序遍历的递归操作，将左侧的节点连缀到右侧节点的后面

1. **递归展开**：对于每个节点，先递归展开其左子树和右子树。
2. **处理左右子树**：
   - 如果左子树不为空，将左子树插入到当前节点和右子树之间。
   - 将左子树置为空，确保链表的结构正确。
3. **终止条件**：当节点为空时，直接返回。

```go
func flatten(root *TreeNode) {
    if root == nil {
        return
    }
    flatten(root.Left)
    flatten(root.Right)
    left := root.Left
    right := root.Right
    root.Left = nil
    root.Right = left
    for root.Right != nil {
        root = root.Right
    }
    root.Right = right
}
```

# 从前序与中序遍历序列构造二叉树

`preorder` 和 `inorder` 均 **无重复** 元素  这句话是题干的核心，利用先序遍历找到根节点，之后利用中序遍历去递归构建

1. **确定根节点**：前序遍历的第一个元素是根节点。
2. **分割中序遍历**：在中序遍历中找到根节点的位置，左边是左子树的中序遍历，右边是右子树的中序遍历。
3. **分割前序遍历**：根据左子树的长度，分割前序遍历中左子树和右子树的部分。
4. **递归构建**：递归构建左子树和右子树。

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }
    rootVal := preorder[0]
    root := &TreeNode{Val: rootVal}
    var rootIndex int
    for i, val := range inorder {
        if val == rootVal {
            rootIndex = i
            break
        }
    }
    //左节点就把左子树传进去进行同样的操作
    root.Left = buildTree(preorder[1:rootIndex+1], inorder[:rootIndex])
    root.Right = buildTree(preorder[rootIndex+1:], inorder[rootIndex+1:])
    return root
}
```

1. `root.Left = buildTree(preorder[1:rootIndex+1], inorder[:rootIndex])`，对于左子树而言，其根节点就是先序遍历原有根节点的下一个，而中序遍历的序列是根节点左侧的部分
2. `root.Right = buildTree(preorder[rootIndex+1:], inorder[rootIndex+1:])`,对于右子树而言，其根节点就是先序遍历原本根节点右侧的第一个，而中序遍历的序列是根节点右侧的部分

# 路径总和 III

1. **双重递归**：
   - **外层递归**：遍历每个节点，作为路径的起点。
   - **内层递归**：从当前节点出发，计算所有可能的路径和，统计等于目标值的路径数目。
2. **前缀和优化**：
   - 使用哈希表记录从根节点到当前节点的路径和及其出现次数。
   - 检查当前路径和与目标值的差是否存在于哈希表中，以确定是否存在满足条件的路径。

```go
func pathSum(root *TreeNode, targetSum int) int {
    if root == nil {
        return 0
    }
    return dfs(root, targetSum) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)
}

func dfs(node *TreeNode, targetSum int) int {
    if node == nil {
        return 0
    }
    count := 0
    //如果子节点符合条件的话就返回
    if node.Val == targetSum {
        count++
    }
    count += dfs(node.Left, targetSum-node.Val)
    count += dfs(node.Right, targetSum-node.Val)
    return count
}
```

相当于是将符合值要求的查找递归给子树了，而总的目标值也要去掉根节点的

优化如下：

```go
func pathSum(root *TreeNode, targetSum int) int {
    prefixSum := make(map[int]int)
    prefixSum[0] = 1
    return helper(root, targetSum, 0, prefixSum)
}

func helper(node *TreeNode, targetSum, currentSum int, prefixSum map[int]int) int {
    if node == nil {
        return 0
    }
    currentSum += node.Val
    count := prefixSum[currentSum-targetSum]
    prefixSum[currentSum]++
    count += helper(node.Left, targetSum, currentSum, prefixSum)
    count += helper(node.Right, targetSum, currentSum, prefixSum)
    prefixSum[currentSum]--
    return count
}
```

# 二叉树的最近公共祖先

1. **递归遍历**：从根节点开始递归遍历二叉树。
2. **终止条件**：
   - 如果当前节点为空，返回`nil`。
   - 如果当前节点是`p`或`q`中的一个，返回当前节点。
3. **递归查询左右子树**：分别在左子树和右子树中查找`p`和`q`。
4. **判断结果**：
   - 如果左右子树的递归调用都返回非空节点，说明当前节点就是LCA。
   - 如果其中一个子树返回非空节点，则返回该节点。

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    // 说明找到了某个节点
    if root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    // 相当于是看一下查询的子结果中有没有存在p q节点
    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    
    return right
}
```

# 二叉树中的最大路径和（难）
