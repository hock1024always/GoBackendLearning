# 最大子数组和

1.考虑前缀

2.尽量考虑操作单个数据，而不是部分子数组

3.递归

```go
func maxSubArray(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	currentMax := nums[0]
	globalMax := nums[0]

	for i := 1; i < len(nums); i++ {
		currentMax = max(nums[i], currentMax+nums[i])
		globalMax = max(globalMax, currentMax)
	}

	return globalMax
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}


```



# 合并区间

```go
func merge(intervals [][]int) [][]int {
	if len(intervals) == 0 {
		return intervals
	}

	// 按区间的起始点排序
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	merged := [][]int{intervals[0]}
	for i := 1; i < len(intervals); i++ {
		last := merged[len(merged)-1]
		current := intervals[i]

		// 如果当前区间的起始点 <= 最后一个区间的结束点，说明有重叠
		if current[0] <= last[1] {
			// 合并区间，结束点取两者较大值
			if current[1] > last[1] {
				last[1] = current[1]
			}
		} else {
			// 无重叠，直接加入
			merged = append(merged, current)
		}
	}

	return merged
}
```



# 轮转数组

#### 使用额外数组

1. **计算实际步数**：`k = k % len(nums)`，避免不必要的轮转。
2. **创建新数组**：将原数组的后 `k` 个元素复制到新数组的前面，前 `len(nums) - k` 个元素复制到新数组的后面。
3. **复制回原数组**：将新数组的内容复制回原数组。

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k = k % n
    if k == 0 {
        return
    }
    rotated := make([]int, n)
    copy(rotated[:k], nums[n-k:])
    copy(rotated[k:], nums[:n-k])
    copy(nums, rotated)
}

```

#### 三次反转

1. **计算实际步数**：`k = k % len(nums)`。
2. **反转整个数组**：将数组完全反转。
3. **反转前 `k` 个元素**：将前 `k` 个元素反转。
4. **反转剩余元素**：将后 `len(nums) - k` 个元素反转。

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k = k % n
    if k == 0 {
        return
    }
    reverse(nums, 0, n-1)
    reverse(nums, 0, k-1)
    reverse(nums, k, n-1)
}

func reverse(nums []int, start, end int) {
    for start < end {
        nums[start], nums[end] = nums[end], nums[start]
        start++
        end--
    }
}
```

#### 环状替换

1. **计算实际步数**：`k = k % len(nums)`。
2. **环状替换**：从起始位置开始，将每个元素移动到其最终位置，直到所有元素都被移动。使用 `count` 来跟踪已处理的元素数量，避免重复处理。

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k = k % n
    if k == 0 {
        return
    }
    count := 0
    for start := 0; count < n; start++ {
        current := start
        prev := nums[start]
        for {
            next := (current + k) % n
            nums[next], prev = prev, nums[next]
            current = next
            count++
            if current == start {
                break
            }
        }
    }
}
```



# 出自身以外数组的乘积

```go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    answer := make([]int, n)
    
    // 计算前缀积
    answer[0] = 1
    for i := 1; i < n; i++ {
        answer[i] = answer[i-1] * nums[i-1]
    }
    
    // 计算后缀积并直接更新 answer
    suffix := 1
    for i := n - 1; i >= 0; i-- {
        answer[i] = answer[i] * suffix
        suffix *= nums[i]
    }
    
    return answer
}
```

1. **初始化 `answer` 数组**：
   - `answer` 数组用于存储前缀积和后缀积的乘积结果。
2. **计算前缀积**：
   - `answer[i]` 初始化为 `1`（因为第一个元素没有前缀）。
   - 遍历数组，`answer[i]` 等于 `answer[i-1] * nums[i-1]`，即 `nums[0..i-1]` 的乘积。
3. **计算后缀积并更新 `answer`**：
   - 使用变量 `suffix` 动态计算从右到左的后缀积。
   - 从数组末尾开始遍历，`answer[i]` 乘以当前的 `suffix`，然后更新 `suffix` 为 `suffix * nums[i]`。

# 缺失的第一个正数（难）