# 移动零

```go
func moveZeroes(nums []int) {
    nonZeroIndex := 0
    for i := 0; i < len(nums); i++ {
        if nums[i] != 0 {
            nums[nonZeroIndex] = nums[i]
            nonZeroIndex++
        }
    }
    for i := nonZeroIndex; i < len(nums); i++ {
        nums[i] = 0
    }
}
```

1. **初始化指针**：`nonZeroIndex`初始为0，用于记录下一个非零元素应该放置的位置。
2. **遍历数组**：使用`i`遍历数组，遇到非零元素时，将其放到`nonZeroIndex`的位置，并移动`nonZeroIndex`。
3. **填充零**：遍历结束后，从`nonZeroIndex`开始到数组末尾，将所有剩余位置置为零。

# 盛最多水的容器

```go
func maxArea(height []int) int {
    max := 0
    left, right := 0, len(height)-1
    for left < right {
        h := min(height[left], height[right])
        w := right - left
        area := h * w
        if area > max {
            max = area
        }
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    return max
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

1. **初始化指针和最大值**：`left`和`right`分别指向数组的两端，`max`初始化为0。
2. **循环计算容量**：在`left`小于`right`的条件下，计算当前容器的容量，并更新`max`。
3. **移动指针**：根据两边的高度决定移动哪一边的指针，总是移动较短的一边，以寻找可能的更大容量。
4. **返回结果**：循环结束后，`max`即为能容纳的最大水量。

# 三数之和

```go
import "sort"

func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    res := [][]int{}
    n := len(nums)

    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

1. **排序数组**：使用`sort.Ints`对数组进行排序，以便后续的双指针操作。
2. **遍历固定第一个数**：外层循环遍历数组，固定`nums[i]`作为三元组的第一个数，跳过重复的`nums[i]`以避免重复结果。
3. **双指针查找**：内层循环使用双指针`left`和`right`查找满足条件的两个数，使得三数之和为0。
4. **去重处理**：在找到符合条件的组合后，跳过所有重复的`nums[left]`和`nums[right]`，并移动指针继续查找。
5. **返回结果**：将所有找到的不重复三元组存入结果数组并返回。



# 接雨水（难）



