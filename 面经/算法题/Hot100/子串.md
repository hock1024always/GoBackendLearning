# 和为K的子数组

```go
func subarraySum(nums []int, k int) int {
    count := 0
    sum := 0
    prefixSum := make(map[int]int)
    prefixSum[0] = 1

    for _, num := range nums {
        sum += num
        if val, exists := prefixSum[sum - k]; exists {
            count += val
        }
        prefixSum[sum]++
    }

    return count
}
```

1. **初始化**：`count`用于统计符合条件的子数组个数，`sum`用于记录当前的前缀和，`prefixSum`哈希表记录前缀和出现的次数，初始时`prefixSum[0] = 1`。
2. **遍历数组**：
   - 更新当前的前缀和`sum`。
   - 检查`sum - k`是否存在于哈希表中。如果存在，说明从某个位置到当前位置的子数组和为k，累加对应的次数到`count`。
   - 将当前前缀和存入哈希表，更新其出现次数。
3. **返回结果**：最终`count`即为和为k的子数组的个数。



# 滑动窗口的最大值（难）







# 最小覆盖子串（难）





