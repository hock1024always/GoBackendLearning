# 搜索插入位置

1. **初始化指针**：设置左指针`left`和右指针`right`分别指向数组的起始和末尾。
2. **二分查找**：在`left`不大于`right`的情况下，计算中间位置`mid`，比较`nums[mid]`与`target`：
   - 如果`nums[mid]`等于`target`，直接返回`mid`。
   - 如果`nums[mid]`小于`target`，说明目标值在右半部分，调整`left`到`mid + 1`。
   - 如果`nums[mid]`大于`target`，说明目标值在左半部分，调整`right`到`mid - 1`。
3. **返回插入位置**：如果循环结束仍未找到目标值，则`left`指针指向的位置即为目标值应该插入的位置。

```go
func searchInsert(nums []int, target int) int {
    //初始化左右指针和数组长度
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return left//找不到的话最终返回的是可以插入的位置
}
```

# 搜索二维矩阵

考察的是如何在二维数组中进行查找的基本二分查找方法

1. **处理空矩阵**：如果矩阵为空或矩阵的行/列为空，直接返回 `false`。
2. **初始化指针**：使用 `left` 和 `right` 分别指向虚拟一维数组的起始和末尾。
3. **二分查找**：
   - 计算中间索引 `mid`，并将其转换为二维矩阵的行和列。
   - 比较中间元素与目标值：
     - 如果相等，返回 `true`。
     - 如果中间元素小于目标值，调整 `left` 指针。
     - 如果中间元素大于目标值，调整 `right` 指针。
4. **终止条件**：如果循环结束仍未找到目标值，返回 `false`。

```go
func searchMatrix(matrix [][]int, target int) bool {
    //处理空矩阵
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }
    //计算一行一列的长度 设置的是一个全矩阵元素大小的左右指针
    m, n := len(matrix), len(matrix[0])
    left, right := 0, m * n - 1
    
    for left <= right {
        mid := left + (right - left) / 2
        //转换成行和列
        row := mid / n
        col := mid % n
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return false
}
```

# 在排序数组中查找元素的第一个和最后一个位置

1. **查找起始位置**：使用二分查找找到第一个等于目标值的位置。
2. **查找结束位置**：使用二分查找找到最后一个等于目标值的位置。
3. **处理不存在情况**：如果找不到目标值，返回 `[-1, -1]`。

```go
func searchRange(nums []int, target int) []int {
    // 处理空数组的情况
    if len(nums) == 0 {
        return []int{-1, -1}
    }
    // 查找第一个等于 target 的位置
    first := findFirst(nums, target)
    if first == -1 {// 如果第一个位置不存在，直接返回 [-1, -1]
        return []int{-1, -1}
    }
    // 查找最后一个等于 target 的位置
    last := findLast(nums, target)
    return []int{first, last}
}

// 辅助函数：查找第一个等于 target 的位置
func findFirst(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            // 如果 mid 是第一个元素，或者前一个元素不等于 target，则 mid 是第一个位置
            if mid == 0 || nums[mid-1] != target {
                return mid
            } else {
                // 否则继续在左半部分查找
                right = mid - 1
            }
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

// 辅助函数：查找最后一个等于 target 的位置
func findLast(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            // 如果 mid 是最后一个元素，或者后一个元素不等于 target，则 mid 是最后一个位置
            if mid == len(nums)-1 || nums[mid+1] != target {
                return mid
            } else {
                // 否则继续在右半部分查找
                left = mid + 1
            }
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

下面这两个判断条件值得一看

`mid == 0 || nums[mid-1] != target`

`mid == len(nums)-1 || nums[mid+1] != target`

# 搜索旋转排序数组

正常的二分查找都是升序或者降序一致的序列，而这道题存在一个转折，这是特殊的地方

1. **初始化指针**：使用两个指针 `left` 和 `right` 分别指向数组的起始和末尾。
2. **二分查找**：
   - 计算中间位置 `mid`。
   - 检查 `nums[mid]` 是否等于 `target`，如果是则返回 `mid`。
   - 判断哪一部分是有序的：
     - 如果 `nums[left] <= nums[mid]`，说明左半部分是有序的：
       - 如果 `target` 在 `nums[left]` 和 `nums[mid]` 之间，则在左半部分继续查找。
       - 否则在右半部分查找。
     - 否则右半部分是有序的：
       - 如果 `target` 在 `nums[mid]` 和 `nums[right]` 之间，则在右半部分继续查找。
       - 否则在左半部分查找。
3. **终止条件**：如果 `left` 超过 `right`，说明目标值不存在，返回 `-1`。

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            return mid
        }
        
        // 判断左半部分是否有序
        if nums[left] <= nums[mid] {
            // 如果 target 在左半部分的范围内
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            // 右半部分有序
            // 如果 target 在右半部分的范围内
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    
    return -1
}
```

为了解决这个差异做出的改动：

1. `nums[left] <= nums[mid]` 用于判断这部分是否有序
2. `nums[left] <= target && target < nums[mid]`因为另外一部分可能存在异常，因此在处理的时候也使用中间值和边值进行判断

# 寻找旋转排序数组中的最小值

这个题目数字差为1，即原始位置值和标号一致

1. **初始化指针**：使用两个指针 `left` 和 `right` 分别指向数组的起始和末尾。
2. **二分查找**：
   - 计算中间位置 `mid`。
   - 比较 `nums[mid]` 和 `nums[right]`：
     - 如果 `nums[mid] < nums[right]`，说明最小值在左半部分，包括 `mid`，调整 `right` 指针到 `mid`。
     - 否则，最小值在右半部分，不包括 `mid`，调整 `left` 指针到 `mid + 1`。
3. **终止条件**：当 `left` 等于 `right` 时，`nums[left]` 即为最小值。

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    
    for left < right {//注意这个条件是小于，因为等于的时候就锁定了最小值
        mid := left + (right-left)/2
        
        if nums[mid] < nums[right] {//说明这部分是正常的递增序列
            right = mid//说明最小的值不会存在于这个正常序列中，而是存在于左侧的mid里
        } else {
            left = mid + 1
        }
    }
    
    return nums[left]
}
```

# 寻找两个正序数组的中位数（难）