# 有效的括号

这种抵消类型匹配问题，都会考虑使用栈

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }

    for _, char := range s {
        switch char {
        case '(', '{', '[':
            stack = append(stack, char)
        case ')', '}', ']':
            if len(stack) == 0 || stack[len(stack)-1] != pairs[char] {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}
```

# 简化路径

```go
func simplifyPath(path string) string {
    
    stack := []string{}
    for _, name := range strings.Split(path, "/") {
        if name == ".." {
            if len(stack) > 0 {
                stack = stack[:len(stack)-1]
            }
        } else if name != "" && name != "." {
            stack = append(stack, name)
        }
    }
    return "/" + strings.Join(stack, "/")
}
```

# 最小栈





# 逆波兰表达式求值





# 基本计算器









# 赎金信





# 同构字符串





# 单词规律





# 有效的字母异位词





# 字母异位词分组





# 两数之和





# 快乐数





# 存在重复元素 II





# 最长连续序列





# 数组中的第K个最大元素





# IPO





# 查找和最小的 K 对数字





# 数据流的中位数

