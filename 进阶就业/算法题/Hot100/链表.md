# 相交链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    pA, pB := headA, headB
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    return pA
}
```

1. **初始化指针**：`pA`和`pB`分别初始化为`headA`和`headB`。
2. **遍历链表**：
   - 如果`pA`到达链表末尾（`nil`），将其重定位到`headB`。
   - 如果`pB`到达链表末尾（`nil`），将其重定位到`headA`。
3. **相遇判断**：当`pA`和`pB`指向同一个节点时，该节点即为相交节点；如果两者同时到达末尾（`nil`），说明链表不相交，返回`nil`。

# 反转链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

1. **基本情况**：链表为空或只有一个节点时，直接返回`head`。
2. **递归调用**：反转`head.Next`，返回的新头节点为`newHead`。
3. **反转当前节点**：将`head.Next.Next`指向`head`，完成局部反转。
4. **断开原链接**：将`head.Next`置为`nil`，防止循环。
5. **返回新头节点**：`newHead`即为反转后的头节点。

# 回文链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func isPalindrome(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return true
    }

    // 找到前半部分的尾节点
    slow, fast := head, head
    for fast.Next != nil && fast.Next.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    // 反转后半部分链表
    secondHalfStart := reverseList(slow.Next)

    // 比较前后两部分
    p1, p2 := head, secondHalfStart
    result := true
    for result && p2 != nil {
        if p1.Val != p2.Val {
            result = false
        }
        p1 = p1.Next
        p2 = p2.Next
    }

    // 恢复链表（可选）
    slow.Next = reverseList(secondHalfStart)

    return result
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    current := head
    for current != nil {
        next := current.Next
        current.Next = prev
        prev = current
        current = next
    }
    return prev
}
```

1. **找到中点**：使用快慢指针`slow`和`fast`，`fast`每次移动两步，`slow`每次移动一步。当`fast`到达末尾时，`slow`位于前半部分的末尾。
2. **反转后半部分**：调用`reverseList`函数反转`slow.Next`开始的链表部分。
3. **比较前后部分**：使用两个指针`p1`和`p2`分别从头节点和反转后的后半部分头节点开始，逐个比较节点值。
4. **恢复链表（可选）**：再次反转后半部分链表以恢复原链表结构（此步骤可根据需求省略）。
5. **返回结果**：根据比较结果返回`true`或`false`。

# 环形链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }
    slow, fast := head, head.Next
    for slow != fast {
        if fast == nil || fast.Next == nil {
            return false
        }
        slow = slow.Next
        fast = fast.Next.Next
    }
    return true
}
```

1. **初始化指针**：`slow`和`fast`初始分别指向`head`和`head.Next`。
2. **循环检测**：
   - 如果`fast`或`fast.Next`为`nil`，说明链表无环，返回`false`。
   - `slow`每次移动一步，`fast`每次移动两步。
3. **相遇检测**：如果`slow`和`fast`相遇，说明有环，返回`true`。

# 环形链表 II

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            break
        }
    }
    if fast == nil || fast.Next == nil {
        return nil
    }
    fast = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    return slow
}
```

1. **初始化指针**：`slow`和`fast`初始都指向`head`。
2. **检测环**：
   - `slow`每次移动一步，`fast`每次移动两步。
   - 如果`fast`或`fast.Next`为`nil`，说明无环，返回`nil`。
   - 如果`slow`和`fast`相遇，说明有环。
3. **找到环入口**：
   - 将`fast`重新指向`head`。
   - `slow`和`fast`同时每次移动一步，直到再次相遇，相遇点即为环的入口节点。
4. **返回结果**：返回环的入口节点或`nil`。

# 合并两个有序链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }

    if l1 != nil {
        current.Next = l1
    } else {
        current.Next = l2
    }

    return dummy.Next
}
```

1. **初始化哑节点和当前指针**：`dummy`节点用于简化操作，`current`初始指向`dummy`。
2. **循环比较和连接节点**：
   - 比较`l1`和`l2`当前节点的值，较小的节点连接到`current`后面。
   - 移动相应链表的指针和`current`指针。
3. **处理剩余节点**：将未遍历完的链表剩余部分直接连接到`current`后面。
4. **返回结果**：`dummy.Next`即为合并后的链表头节点。

# 两数相加

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil {
        var val1, val2 int
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10}
        current = current.Next
    }

    if carry > 0 {
        current.Next = &ListNode{Val: carry}
    }

    return dummy.Next
}
```

1. **初始化**：`dummy`节点用于简化操作，`current`指向`dummy`，`carry`初始为0。
2. **遍历链表**：
   - 如果`l1`或`l2`不为空，取出当前节点的值，否则取0。
   - 计算当前位的和`sum`，并更新`carry`。
   - 创建新节点存储`sum % 10`，并移动`current`指针。
3. **处理剩余进位**：如果遍历结束后`carry`不为0，创建新节点存储`carry`。
4. **返回结果**：`dummy.Next`即为结果链表的头节点。

# 删除链表的倒数第 N 个结点

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    fast, slow := dummy, dummy

    // 快指针先移动n步
    for i := 0; i <= n; i++ {
        fast = fast.Next
    }

    // 同时移动快慢指针，直到快指针到达末尾
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }

    // 删除慢指针的下一个节点
    slow.Next = slow.Next.Next

    return dummy.Next
}
```

1. **初始化哑节点**：`dummy`节点用于简化边界条件的处理，特别是当需要删除头节点时。
2. **移动快指针**：快指针`fast`先向前移动n+1步，这样快指针和慢指针之间相隔n个节点。
3. **同时移动快慢指针**：快指针和慢指针同时向前移动，直到快指针到达链表末尾。此时，慢指针指向要删除节点的前一个节点。
4. **删除节点**：将慢指针的`next`指向`next.next`，从而跳过要删除的节点。
5. **返回结果**：`dummy.Next`即为删除节点后的链表头节点。

# 两两交换链表中的节点

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    dummy := &ListNode{Next: head}
    current := dummy

    for current.Next != nil && current.Next.Next != nil {
        first := current.Next
        second := current.Next.Next

        // 交换节点
        current.Next = second
        first.Next = second.Next
        second.Next = first

        // 移动current指针
        current = first
    }

    return dummy.Next
}
```

1. **初始化哑节点和当前指针**：`dummy`节点用于简化操作，`current`初始指向`dummy`。
2. **循环交换相邻节点**：
   - 检查`current`后面是否有至少两个节点。
   - 记录这两个节点`first`和`second`。
   - 交换`first`和`second`的位置，并更新指针关系。
3. **移动当前指针**：`current`移动到交换后的第二个节点（即原来的`first`）。
4. **返回结果**：`dummy.Next`即为交换后的链表头节点。

# K 个一组翻转链表（难）





# 随机链表的复制

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }

    // 创建原节点到新节点的映射
    nodeMap := make(map[*Node]*Node)
    current := head
    for current != nil {
        nodeMap[current] = &Node{Val: current.Val}
        current = current.Next
    }

    // 设置新节点的Next和Random指针
    current = head
    for current != nil {
        newNode := nodeMap[current]
        if current.Next != nil {
            newNode.Next = nodeMap[current.Next]
        }
        if current.Random != nil {
            newNode.Random = nodeMap[current.Random]
        }
        current = current.Next
    }

    return nodeMap[head]
}
```

1. **初始化哈希表**：`nodeMap`用于存储原节点到新节点的映射关系。
2. **第一次遍历**：遍历原链表，为每个原节点创建一个新节点，并存入哈希表。
3. **第二次遍历**：再次遍历原链表，根据哈希表为新节点的`Next`和`Random`指针赋值。
4. **返回结果**：哈希表中原链表头节点对应的新节点即为复制链表的头节点。

# 排序链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    // 分割链表
    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    mid := slow.Next
    slow.Next = nil

    // 递归排序子链表
    left := sortList(head)
    right := sortList(mid)

    // 合并两个有序链表
    return merge(left, right)
}

func merge(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }

    if l1 != nil {
        current.Next = l1
    } else {
        current.Next = l2
    }

    return dummy.Next
}
```

1. **分割链表**：使用快慢指针找到链表的中点`mid`，将链表分成`head`到`slow`和`mid`到末尾两部分。
2. **递归排序**：对分割后的两个子链表分别递归调用`sortList`进行排序。
3. **合并链表**：`merge`函数将两个已排序的子链表合并成一个有序链表，通过比较节点值逐个连接。
4. **返回结果**：最终返回合并后的有序链表的头节点。

# 合并 K 个升序链表（难）



# LRU 缓存

```go
type LRUCache struct {
    capacity int
    cache    map[int]*DLinkedNode
    head     *DLinkedNode
    tail     *DLinkedNode
}

type DLinkedNode struct {
    key   int
    value int
    prev  *DLinkedNode
    next  *DLinkedNode
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*DLinkedNode),
        head:     &DLinkedNode{},
        tail:     &DLinkedNode{},
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
        return
    }
    if len(this.cache) == this.capacity {
        removed := this.removeTail()
        delete(this.cache, removed.key)
    }
    newNode := &DLinkedNode{key: key, value: value}
    this.cache[key] = newNode
    this.addToHead(newNode)
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
```

1. **数据结构**：
   - `LRUCache`包含容量、哈希表`cache`、双向链表的头尾哨兵节点。
   - `DLinkedNode`是双向链表节点，包含键、值、前后指针。
2. **构造函数**：初始化容量、哈希表和头尾节点，并连接它们。
3. **Get方法**：
   - 检查键是否存在，存在则移动节点到头部并返回值。
   - 不存在返回-1。
4. **Put方法**：
   - 键存在则更新值并移到头部。
   - 键不存在则创建新节点，添加到头部；若容量满，移除尾部节点并删除哈希表对应项。
5. **辅助方法**：
   - `addToHead`：将节点添加到头部。
   - `removeNode`：从链表中移除节点。
   - `moveToHead`：移动节点到头部。
   - `removeTail`：移除尾部节点并返回。