# 矩阵置零

```go
func setZeroes(matrix [][]int) {
    m, n := len(matrix), len(matrix[0])
    firstRowZero, firstColZero := false, false

    // 检查首行是否有零
    for j := 0; j < n; j++ {
        if matrix[0][j] == 0 {
            firstRowZero = true
            break
        }
    }

    // 检查首列是否有零
    for i := 0; i < m; i++ {
        if matrix[i][0] == 0 {
            firstColZero = true
            break
        }
    }

    // 使用首行和首列标记其他行列的零
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if matrix[i][j] == 0 {
                matrix[i][0] = 0
                matrix[0][j] = 0
            }
        }
    }

    // 根据标记置零其他行列
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if matrix[i][0] == 0 || matrix[0][j] == 0 {
                matrix[i][j] = 0
            }
        }
    }

    // 处理首行
    if firstRowZero {
        for j := 0; j < n; j++ {
            matrix[0][j] = 0
        }
    }

    // 处理首列
    if firstColZero {
        for i := 0; i < m; i++ {
            matrix[i][0] = 0
        }
    }
}
```

1. **检查首行和首列**：首先确定首行和首列是否需要被全部置零，用`firstRowZero`和`firstColZero`记录。
2. **标记其他行列**：遍历矩阵的其余部分，遇到零元素时，将对应的首行和首列的位置置零，作为标记。
3. **置零操作**：根据首行和首列的标记，将对应的行和列置零。
4. **处理首行和首列**：根据初始检查的结果，决定是否将首行或首列全部置零。

# 螺旋矩阵

```
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    m, n := len(matrix), len(matrix[0])
    res := make([]int, 0, m*n)
    top, bottom, left, right := 0, m-1, 0, n-1

    for top <= bottom && left <= right {
        // 从左到右遍历上边界
        for j := left; j <= right; j++ {
            res = append(res, matrix[top][j])
        }
        top++

        // 从上到下遍历右边界
        for i := top; i <= bottom; i++ {
            res = append(res, matrix[i][right])
        }
        right--

        if top <= bottom {
            // 从右到左遍历下边界
            for j := right; j >= left; j-- {
                res = append(res, matrix[bottom][j])
            }
            bottom--
        }

        if left <= right {
            // 从下到上遍历左边界
            for i := bottom; i >= top; i-- {
                res = append(res, matrix[i][left])
            }
            left++
        }
    }
    return res
}
```

1. **初始化边界**：`top`、`bottom`、`left`、`right`分别表示当前螺旋遍历的上下左右边界。
2. **螺旋遍历**：
   - **从左到右**：遍历当前上边界的所有元素，完成后上边界下移。
   - **从上到下**：遍历当前右边界的元素，完成后右边界左移。
   - **从右到左**：如果上边界未超过下边界，遍历当前下边界的元素，完成后下边界上移。
   - **从下到上**：如果左边界未超过右边界，遍历当前左边界的元素，完成后左边界右移。
3. **终止条件**：当上边界超过下边界或左边界超过右边界时，循环结束，返回结果数组。

# 旋转图像

```go
func rotate(matrix [][]int) {
    n := len(matrix)
    
    // 第一步：转置矩阵（沿主对角线交换）
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    
    // 第二步：水平翻转每一行
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
        }
    }
}
```

1. **转置矩阵**：
   - 外层循环 `i` 从 0 到 n-1
   - 内层循环 `j` 从 `i` 到 n-1（只需要处理对角线以上的元素）
   - 交换 `matrix[i][j]` 和 `matrix[j][i]`
2. **水平翻转**：
   - 对每一行 `i`，从两端向中间交换元素
   - 交换 `matrix[i][j]` 和 `matrix[i][n-1-j]`，直到到达行中间



# 搜索二维矩阵 II

```go
func searchMatrix(matrix [][]int, target int) bool {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }
    
    m, n := len(matrix), len(matrix[0])
    row, col := 0, n-1 // 从右上角开始
    
    for row < m && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] > target {
            col-- // 向左移动一列
        } else {
            row++ // 向下移动一行
        }
    }
    
    return false
}
```

1. **边界检查**：首先检查矩阵是否为空
2. **初始化位置**：从右上角 (0, n-1) 开始搜索
3. **搜索过程**：
   - 如果找到目标值，立即返回 true
   - 如果当前值大于目标值，向左移动（排除当前列）
   - 如果当前值小于目标值，向下移动（排除当前行）
4. **越界检查**：如果行或列越界仍未找到，返回 false