# 买卖股票的最佳时机

1. **初始化变量**：`minPrice` 设置为第一天的价格，`maxProfit` 初始化为 0。
2. **遍历价格数组**：
   - 更新 `minPrice` 为当前价格和 `minPrice` 中的较小值。
   - 计算当前价格与 `minPrice` 的差值，更新 `maxProfit` 为当前差值和 `maxProfit` 中的较大值。
3. **返回结果**：遍历结束后，`maxProfit` 即为最大利润。

```go
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    
    minPrice := prices[0]
    maxProfit := 0
    
    for i := 1; i < len(prices); i++ {
        // 更新最低价格
        if prices[i] < minPrice {
            minPrice = prices[i]
        } else {
            // 计算当前利润并更新最大利润
            currentProfit := prices[i] - minPrice
            if currentProfit > maxProfit {
                maxProfit = currentProfit
            }
        }
    }
    
    return maxProfit
}
```

1. 因为卖出的日子是固定的，只要在之前最低买入即可
2. 如果是在最高价卖出之后还有一组这样的数据，使用下面更新最大利润的方式去实现这个的纠正

# 跳跃游戏

1. **初始化变量**：`maxReach` 设置为 0。
2. **遍历数组**：
   - 如果当前位置 `i` 大于 `maxReach`，返回 `false`。
   - 更新 `maxReach` 为 `max(maxReach, i + nums[i])`。
   - 如果 `maxReach` 已经大于等于最后一个位置，提前返回 `true`。
3. **返回结果**：遍历结束后，若 `maxReach` 能覆盖最后一个位置，返回 `true`。

```go
func canJump(nums []int) bool {
    maxReach := 0
    for i := 0; i < len(nums); i++ {
        if i > maxReach {//说明在这个循环中，这个位置是无法到达的
            return false
        }
        maxReach = max(maxReach, i + nums[i])
        if maxReach >= len(nums)-1 {
            return true
        }
    }
    return true
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```



# 跳跃游戏 II

1. **初始化变量**：`jumps` 记录跳跃次数，`maxReach` 记录当前能到达的最远位置，`end` 记录当前跳跃的边界。
2. **遍历数组**：
   - 更新 `maxReach` 为 `max(maxReach, i + nums[i])`。
   - 当 `i` 到达 `end` 时，增加跳跃次数，并更新 `end` 为 `maxReach`。
3. **返回结果**：遍历结束后，`jumps` 即为最小跳跃次数。

```go
func jump(nums []int) int {
    // 如果数组长度为0或1，不需要跳跃
    if len(nums) <= 1 {
        return 0
    }

    jumps := 0          // 记录跳跃次数
    maxReach := nums[0] // 当前能到达的最远位置
    end := nums[0]      // 当前跳跃的边界

    for i := 1; i < len(nums); i++ {
        // 如果已经到达最后一个位置，直接返回跳跃次数
        if i == len(nums)-1 {
            return jumps + 1
        }

        // 更新当前能到达的最远位置
        maxReach = max(maxReach, i + nums[i])

        // 当到达当前跳跃的边界时，增加跳跃次数并更新边界
        if i == end {
            jumps++ //目前的跳跃次数
            end = maxReach //截至此跳的移动距离
        }
    }

    return jumps
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```



# 划分字母区间

1. **记录字母最后出现的位置**：使用哈希表或数组记录每个字母在字符串中最后出现的位置。
2. **遍历字符串**：
   - 初始化当前片段的开始和结束位置。
   - 遍历字符串时，更新当前片段的结束位置为当前字母的最后出现位置。
   - 当遍历到当前片段的结束位置时，记录片段长度，并更新开始位置为下一个字符。
3. **返回结果**：最终返回所有片段长度的列表。

```go
func partitionLabels(s string) []int {
    // 记录每个字母最后出现的位置
    lastOccurrence := make(map[rune]int)
    for i, ch := range s {
        lastOccurrence[ch] = i
    }

    var result []int
    start, end := 0, 0

    for i, ch := range s {
        // 更新当前片段的结束位置
        if lastOccurrence[ch] > end {
            end = lastOccurrence[ch]
        }
        // 当遍历到当前片段的结束位置时，记录片段长度
        if i == end {
            result = append(result, end - start + 1)
            start = i + 1
        }
    }

    return result
}
```