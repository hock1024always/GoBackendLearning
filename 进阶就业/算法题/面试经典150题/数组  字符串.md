# 合并两个有序数组（9.15.1）

## 方法1 追加之后排序

这个方法针对无序数组也可以使用

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //使用数组处理方法直接处理
    copy(nums1[m:],nums2)//追加切片
    sort.Ints(nums1)//对整形数组的排序方法
}
```

## 方法2 双指针法

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //创建结果数组并且进行赋值
    result := make([]int,0,m+n)
    //创建左右指针
    p1 := 0
    p2 := 0
    //赋值
    for {
        //防止nums中有空切片  并且顺带可以简化for循环
        if p1==m{
            result=append(result,nums2[p2:]...)
            break
        }
        if p2==n{
            result=append(result,nums1[p1:]...)
            break
        } 

        if nums1[p1]>=nums2[p2]{
            result = append(result,nums2[p2])
            p2++
            continue
        }else{
            result = append(result,nums1[p1])
            p1++
            continue
        }
    }
    copy(nums1,result)
}    
```

### 注意

```go
result := make([]int,m+n)//这样写再加上append方法，会造成前面m+n个元素全为0
```

## 知识点

### make方法

`make` 是 Go 语言中用于**初始化内建引用类型（slice、map、channel）** 的函数，它**分配内存并初始化**相应的数据结构，返回的是类型本身（而不是指针）。

#### 用于切片 (Slice) - *力扣最常用*

切片是动态数组，是解决数组类题目的核心数据结构。

**语法：**

```go
// 语法1: 指定长度和容量
slice := make([]T, length, capacity)

// 语法2: 省略容量，则长度 == 容量
slice := make([]T, length)
```
*   `T`: 切片元素的类型 (如 `int`, `string`, `byte`)
*   `length`: 切片的**当前长度**（已有元素个数）
*   `capacity`: 切片的**总容量**（底层数组能容纳的元素个数）

**力扣实战技巧：**

1.  **预分配内存以避免频繁扩容**：这是最重要的性能优化点。如果你能预估结果切片的大致大小，使用 `make` 预先分配足够的 `capacity` 可以避免 `append` 操作时底层数组的多次重新分配和拷贝，极大提升性能。
    
    *   **例子 (力扣 509. 斐波那契数)**：你知道要计算前 N 个斐波那契数。
        ```go
        func fib(n int) int {
            if n <= 1 {
                return n
            }
            // 预分配一个长度为 n+1 的切片，避免后续 append 的扩容开销
            dp := make([]int, n+1)
            dp[0], dp[1] = 0, 1
            for i := 2; i <= n; i++ {
                dp[i] = dp[i-1] + dp[i-2]
            }
            return dp[n]
        }
        ```
    
2.  **创建空切片但有容量**：当你需要一个初始为空的切片，但又知道即将添加大量元素时。
    *   **例子**：收集二叉树遍历的结果。
        ```go
        // 假设你知道树节点大约有1000个
        result := make([]int, 0, 1000)
        // 然后使用 result = append(result, value) 添加元素，效率极高
        ```

3.  **创建具有初始长度的切片**：当你需要直接通过索引 `dp[i]` 赋值，而不是使用 `append` 时，必须指定足够的 `length`。
    *   **动态规划 (DP) 问题**：几乎所有的 DP 题都需要先创建一个 `dp` 数组（切片）。
        ```go
        // 力扣 70. 爬楼梯
        func climbStairs(n int) int {
            if n <= 2 {
                return n
            }
            dp := make([]int, n+1) // 创建长度为 n+1 的切片
            dp[1] = 1
            dp[2] = 2
            for i := 3; i <= n; i++ {
                dp[i] = dp[i-1] + dp[i-2] // 直接按索引赋值
            }
            return dp[n]
        }
        ```

#### 用于映射 (Map) - *也很常用*

Map 用于存储键值对，解决需要快速查找、计数的题目。

**语法：**

```go
m := make(map[KeyType]ValueType)
m := make(map[KeyType]ValueType, initialCapacity) // 推荐指定初始容量
```
*   `initialCapacity`: 提示 Go 运行时预先分配大约能存储 `initialCapacity` 个元素的空间。**虽然不是严格的限制，但指定一个合理的值可以避免初期的内存重整，提升性能。**

**力扣实战技巧：**

1.  **用于计数**：统计元素出现的频率。
    *   **例子 (力扣 1. 两数之和)**：虽然最优解是一遍哈希，但也能体现 map 的创建。
        ```go
        func twoSum(nums []int, target int) []int {
            // 创建一个map，key是数字，value是索引
            numMap := make(map[int]int, len(nums)) // 建议指定容量为nums的长度
            for i, num := range nums {
                complement := target - num
                if idx, ok := numMap[complement]; ok {
                    return []int{idx, i}
                }
                numMap[num] = i
            }
            return nil
        }
        ```

2.  **用于记录状态**：记录访问过的节点或状态，避免重复处理（如图的遍历、回溯算法）。
    *   **例子**：克隆图（力扣 133）、避免回溯中的重复选择。

#### 用于通道 (Channel) - *并发题目中使用*

Channel 用于 goroutine 之间的通信，在并发类的题目中可能会用到。

**语法：**

```go
ch := make(chan T)    // 无缓冲通道
ch := make(chan T, n) // 带缓冲通道，缓冲区大小为 n
```
*   在力扣的算法题中，单纯使用 channel 的情况较少，除非题目明确要求并发。

#### 总结与对比 (`make` vs `new`)

| 特性         | `make`                                                       | `new`                                                        |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **适用类型** | 仅用于内建引用类型：`slice`, `map`, `channel`                | 用于任何类型（包括值类型和自定义结构体）                     |
| **返回值**   | **类型 T 本身** (e.g., `[]int`, `map[int]int`)               | **指向该类型的指针** (`*T`)                                  |
| **初始化**   | **会初始化**内存（置零值），并设置好内部数据结构（如 slice 的 len/cap） | **只分配内存**，并将内存置为零值（`nil` for references, `0` for numbers, `""` for strings），返回指向这块零值内存的指针 |

**错误示例：**
```go
var s *[]int = new([]int) // s 现在是一个指向 nil 切片的指针
*s = make([]int, 10)      // 必须这样使用：先 new 出一个指针，再让指针指向 make 出来的切片
// 通常我们直接写更简单： s := make([]int, 10)
```

#### 力扣题刷技巧

1.  **看到数组、字符串、动态规划题**：第一反应想到 `make([]T, len, cap)` 来创建你的切片（DP 表、结果集）。
2.  **看到需要查找、去重、计数的题**：第一反应想到 `make(map[K]V)` 来创建你的映射。
3.  **养成预分配容量的习惯**：在知道或能估算数据规模时，始终为 `make` 函数指定 `capacity` 参数。这是一个简单且有效的性能优化手段，能让你的解法跑得更快。

### append方法

#### 追加单个元素

```go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4)  // [1, 2, 3, 4]
```

#### 追加多个元素

```go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4, 5, 6)  // [1, 2, 3, 4, 5, 6]
```

#### 追加另一个切片

```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}
slice1 = append(slice1, slice2...)  // [1, 2, 3, 4, 5, 6]
```

#### 下面内容了解一下即可

**重要特性**

1. **自动扩容**：当切片容量不足时，`append` 会自动分配一个新的底层数组，通常是原容量的2倍（当长度小于1024时）。

2. **返回值**：`append` 总是返回一个新的切片，必须将返回值赋给原切片变量。

3. **零值切片**：可以向 `nil` 切片追加元素：

   ```go
   var s []int
   s = append(s, 1)  // [1]
   ```

**性能考虑**

- 频繁的 `append` 操作可能导致多次内存分配和复制

- 如果知道最终大小，可以预先分配容量：

  ```go
  s := make([]int, 0, 100)  // 长度为0，容量为100
  ```

**常见错误**

```go
s := []int{1, 2, 3}
_ = append(s, 4)  // 错误：没有使用返回值
// s 仍然是 [1, 2, 3]
```

`append` 是 Go 中处理动态数组增长的主要方式，理解它的工作原理对于编写高效的 Go 代码非常重要。

### copy方法

`copy` 是 Go 语言中用于复制切片内容的内置函数，常用于将一个切片的内容复制到另一个切片中。

```go
copy(dst, src []T) int
```

- 返回实际复制的元素个数（取 dst 和 src 长度的较小值）

#### 用法

```go
nums1 := make([]int, 10)  // 假设 nums1 有足够容量
nums2 := []int{4, 5, 6}
m := 5  // 从 nums1 的第 m 个位置开始复制

n := copy(nums1[m:], nums2)  // 将 nums2 复制到 nums1[m:] 的位置
// n 是实际复制的元素数
```

#### 以下内容了解一下即可

1. 不会自动扩容，目标切片必须有足够空间
2. 可以部分复制（取决于目标切片的剩余空间）
3. 常用于合并切片或覆盖切片部分内容

**示例：合并两个有序切片**

```go
nums1 := make([]int, len(nums1Original)+len(nums2)
copy(nums1, nums1Original)
copy(nums1[len(nums1Original):], nums2)
```

### sort包

`sort` 包是 Go 标准库中用于排序和搜索的包，提供了对切片和用户定义集合进行排序的功能。

#### 基本类型排序方法

1. 整型排序

```go
func Ints(x []int)                  // 对 int 切片进行升序排序
func IntsAreSorted(x []int) bool    // 检查 int 切片是否已排序
```

2. 浮点数排序

```go
func Float64s(x []float64)          // 对 float64 切片进行升序排序
func Float64sAreSorted(x []float64) bool  // 检查 float64 切片是否已排序
```

3. 字符串排序

```go
func Strings(x []string)            // 对 string 切片进行升序排序(按字典序)
func StringsAreSorted(x []string) bool  // 检查 string 切片是否已排序
```

#### 通用排序接口

1. Slice 排序 (Go 1.8+)

```go
func Slice(x interface{}, less func(i, j int) bool)  // 根据 less 函数对切片排序
func SliceStable(x interface{}, less func(i, j int) bool)  // 稳定排序
func SliceIsSorted(x interface{}, less func(i, j int) bool) bool  // 检查是否已排序
```

2. 自定义排序接口

```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
func Sort(data Interface)          // 排序
func Stable(data Interface)       // 稳定排序
func IsSorted(data Interface) bool // 检查是否已排序
```

#### 搜索方法

```go
func SearchInts(a []int, x int) int      // 在已排序的 int 切片中搜索 x
func SearchFloat64s(a []float64, x float64) int  // 在已排序的 float64 切片中搜索
func SearchStrings(a []string, x string) int  // 在已排序的 string 切片中搜索
func Search(n int, f func(int) bool) int  // 通用二分搜索
```

#### 逆序排序

Go 1.21+ 引入了新的逆序排序方式：
```go
// 对整型切片降序排序
sort.Sort(sort.Reverse(sort.IntSlice(nums)))

// Go 1.21+ 更简洁的方式
slices.SortFunc(nums, func(a, b int) int {
    return b - a  // 降序排序
})
```

#### 实用示例

1. 自定义结构体排序

```go
type Person struct {
    Name string
    Age  int
}

people := []Person{
    {"Alice", 25},
    {"Bob", 20},
}

// 按年龄排序
sort.Slice(people, func(i, j int) bool {
    return people[i].Age < people[j].Age
})
```

2. 搜索示例

```go
nums := []int{1, 3, 5, 7, 9}
x := 5
pos := sort.SearchInts(nums, x)  // 返回 2
```

3. 检查切片是否已排序

```go
if sort.IntsAreSorted(nums) {
    fmt.Println("切片已排序")
}
```

#### 性能提示

1. 对于基本类型，优先使用 `sort.Ints` 等特定函数，它们比通用 `sort.Slice` 更快
2. 需要保持相等元素原始顺序时，使用 `Stable` 系列方法
3. 对大型数据集，考虑使用 `sort.Slice` 而非实现 `sort.Interface` 接口，代码更简洁
4. `sort` 包提供了强大而灵活的排序功能，是 Go 语言中处理有序数据的核心工具之一。

# 移除元素（9.15.2）

## 方法1：前后指针法

```go
func removeElement(nums []int, val int) int {
    //创建前后指针以及最终元素个数的记录
    follow := 0
    result := 0
    for front,_ := range nums{
        if nums[front] != val{
            nums[follow]=nums[front]
            result++
            front++
            follow++
        }else{
            front++
        }
    }
    return result
}
```

## 知识点

### 快慢指针写法

```go
func removeElement(nums []int, val int) int {
    slow := 0 // 慢指针，指向下一个要放置非val元素的位置
    
    for fast := 0; fast < len(nums); fast++ {
        if nums[fast] != val {
            nums[slow] = nums[fast]
            slow++
        }
    }
    
    return slow
}
```

### range方法

好的！为您总结Go语言`range`方法在力扣题目中的使用要点，特别针对算法题目的特点：

```go
for index, value := range collection {
    // 循环体
}
```

#### 数组/切片（最常用）

```go
nums := []int{1, 2, 3, 4, 5}

// 方式1：获取索引和值（推荐）
for i, num := range nums {
    fmt.Printf("nums[%d] = %d\n", i, num)
}

// 方式2：只获取值
for _, num := range nums {
    fmt.Printf("值: %d\n", num)
}

// 方式3：只获取索引
for i := range nums {
    fmt.Printf("索引: %d, 值: %d\n", i, nums[i])
}
```

#### 字符串（字符遍历）

```go
s := "hello"

// 遍历字符串（按rune遍历，支持中文）
for i, char := range s {
    fmt.Printf("位置%d: %c (Unicode: %U)\n", i, char, char)
}
```

#### Map（无序遍历）

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}

// 遍历map（顺序随机）
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}
```

#### 力扣题目中的实用技巧

1. 原地修改数组

   ```go
   // 错误：修改的是副本，不影响原数组
   for _, num := range nums {
       num = num * 2  // 无效！
   }
   
   // 正确：通过索引修改原数组
   for i := range nums {
       nums[i] = nums[i] * 2  // 有效！
   }
   ```

2. 双指针技巧中的range

   ```go
   func twoSum(nums []int, target int) []int {
       // 使用range遍历，配合map快速查找
       seen := make(map[int]int)
       for i, num := range nums {
           complement := target - num
           if idx, exists := seen[complement]; exists {
               return []int{idx, i}
           }
           seen[num] = i
       }
       return nil
   }
   ```

3. 字符串处理

   ```go
   func countCharacters(s string) int {
       count := 0
       for _, char := range s {
           if char != ' ' {
               count++
           }
       }
       return count
   }
   ```

4. 矩阵遍历（二维数组）

   ```go
   matrix := [][]int{{1,2,3}, {4,5,6}, {7,8,9}}
   
   // 遍历二维数组
   for i, row := range matrix {
       for j, value := range row {
           fmt.Printf("matrix[%d][%d] = %d\n", i, j, value)
       }
   }
   ```

####  常见陷阱与注意事项

1. 值拷贝问题

   ```go
   nums := []int{1, 2, 3}
   for _, num := range nums {
       num++  // 这只是修改副本，原数组不变！
   }
   // nums仍然是[1, 2, 3]
   ```

2. 性能考虑

   ```go
   // 对于大数组，直接使用索引可能更快
   bigArray := make([]int, 1000000)
   
   // 较慢：每次迭代都有值拷贝
   for _, value := range bigArray {
       _ = value
   }
   
   // 较快：直接通过索引访问
   for i := range bigArray {
       _ = bigArray[i]
   }
   ```

3. 边界情况处理

   ```go
   // 空数组/切片不会panic
   var empty []int
   for i, num := range empty {
       fmt.Println(i, num)  // 不会执行
   }
   
   // nil切片也不会panic
   var nilSlice []int = nil
   for i, num := range nilSlice {
       fmt.Println(i, num)  // 不会执行
   }
   ```

#### 力扣实战示例

1. 移除元素

   ```go
   func removeElement(nums []int, val int) int {
       slow := 0
       // 使用range遍历，但通过索引修改原数组
       for _, num := range nums {
           if num != val {
               nums[slow] = num
               slow++
           }
       }
       return slow
   }
   ```

2. 反转字符串

   ```go
   func reverseString(s []byte) {
       // 使用range获取索引，进行双指针交换
       for i := range s[:len(s)/2] {
           j := len(s) - 1 - i
           s[i], s[j] = s[j], s[i]
       }
   }
   ```

3. 寻找重复元素

   ```go
   func findDuplicate(nums []int) int {
       seen := make(map[int]bool)
       for _, num := range nums {
           if seen[num] {
               return num
           }
           seen[num] = true
       }
       return -1
   }
   ```

#### 总结

1. **优先使用索引**：在需要修改原数组时，使用`for i := range`形式
2. **值遍历只读**：`for _, value := range`中的value是副本，不能修改原数据
3. **map遍历无序**：不要依赖map的遍历顺序
4. **性能敏感时**：大数组考虑直接使用索引访问
5. **安全遍历**：range对nil和空集合是安全的

# （须回看）删除有序数组中的重复项（9.15.3）

## 快慢指针法

```go
func removeDuplicates(nums []int) int {
    //异常情况
    length:=len(nums)
    if length == 0{
        return 0
    }
    
    //慢指针
    slow := 0

    //快指针起始遍历
    for fast:=1;fast<length;fast++{
        if nums[fast]!=nums[slow]{
            slow++
            nums[slow]=nums[fast]
        }
    }

    return slow+1
}
```

### 注意1

下面这段代码存在问题：

对于输入 `[1,1,2]`，当 `fast = 1`（指向第二个1）时：

- `nums[fast] == nums[fast+1]` → `1 == 2` → false
- 进入 `else` 分支：`fast++` → `fast = 2`
- 现在 `fast = 2`，但数组长度是3（索引0,1,2）
- 下一次循环：`if fast == length-1` → `2 == 2`，应该跳出循环

**但是**，如果数组是 `[1,1,1]`：

- 内层循环会一直 `fast++`，直到 `fast = 2`
- 然后检查 `nums[2] != nums[3]` → 访问 `nums[3]` 导致越界

```go
func removeDuplicates(nums []int) int {
    //慢指针
    fast,slow := 0,0
    length := len(nums)
    
    for {
        //弹出条件
        if fast == length-1{
            break
        }

        if nums[fast]==nums[fast+1]{
            for{
                if nums[fast]!=nums[fast+1]{
                    break
                }
                fast++
            }
            fast++
            slow++
            nums[slow]=nums[fast]
        }else{
            fast++
            slow++
            nums[slow]=nums[fast]
        }

    }
    return slow+1
}
```

### 注意2

```go
return slow++  // 错误！
```

1. **语法错误**：Go 的 `return` 语句不能包含表达式，只能返回值
2. **逻辑错误**：即使语法正确，`slow++` 是后置自增，会先返回 `slow` 的值，然后再自增

因此要写成：

```go
return slow+1
```

## 哈希表（如果不是非严格递增就要用到）

### 基本操作

```go
// 创建哈希表
m := make(map[keyType]valueType)

// 字面量初始化
m := map[string]int{"a": 1, "b": 2}

// 基本操作
m["key"] = value      // 插入/更新
value := m["key"]     // 读取
delete(m, "key")      // 删除
len(m)                // 获取大小
```

### 力扣常用哈希表模式

#### 频率统计（最常用）

```go
// 统计元素频率
func countFrequency(nums []int) map[int]int {
    freq := make(map[int]int)
    for _, num := range nums {
        freq[num]++
    }
    return freq
}

// 字符串字符统计
func charCount(s string) map[rune]int {
    count := make(map[rune]int)
    for _, char := range s {
        count[char]++
    }
    return count
}
```

#### 快速查找存在性
```go
// 检查重复元素
func hasDuplicate(nums []int) bool {
    seen := make(map[int]bool)
    for _, num := range nums {
        if seen[num] {
            return true
        }
        seen[num] = true
    }
    return false
}

// 两数之和（经典题目）
func twoSum(nums []int, target int) []int {
    indexMap := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if idx, exists := indexMap[complement]; exists {
            return []int{idx, i}
        }
        indexMap[num] = i
    }
    return nil
}
```

#### 分组归类
```go
// 按某种规则分组
func groupAnagrams(strs []string) [][]string {
    groups := make(map[string][]string)
    for _, str := range strs {
        key := sortString(str) // 对字符串排序作为key
        groups[key] = append(groups[key], str)
    }
    
    result := make([][]string, 0, len(groups))
    for _, group := range groups {
        result = append(result, group)
    }
    return result
}
```

### 高级使用技巧

#### 存在性检查的两种方式

```go
m := map[string]int{"a": 1}

// 方式1：使用双返回值（推荐）
if value, exists := m["key"]; exists {
    // key存在
} else {
    // key不存在
}

// 方式2：使用零值特性（小心陷阱）
value := m["key"] // 不存在的key返回零值
if value != 0 {   // 如果0是有效值，这会出错！
    // ...
}
```

#### 默认值处理
```go
// 安全的计数器模式
func safeIncrement(m map[string]int, key string) {
    if _, exists := m[key]; !exists {
        m[key] = 0 // 初始化
    }
    m[key]++
}

// 或者使用一行代码
m[key] = m[key] + 1 // 如果key不存在，m[key]返回0
```

#### 遍历技巧
```go
m := map[int]string{1: "a", 2: "b", 3: "c"}

// 遍历键值对（顺序随机！）
for key, value := range m {
    fmt.Printf("%d: %s\n", key, value)
}

// 只遍历键
for key := range m {
    fmt.Println(key)
}

// 只遍历值
for _, value := range m {
    fmt.Println(value)
}
```

### 常见陷阱与注意事项

#### 并发安全问题
```go
// 错误：并发读写map
go func() { m["a"] = 1 }()
go func() { _ = m["a"] }() // 可能panic!

// 解决方案：使用sync.Map或互斥锁
var mu sync.Mutex
mu.Lock()
m["a"] = 1
mu.Unlock()
```

#### 引用类型陷阱
```go
// map的值是引用类型时要注意
m := make(map[string][]int)
m["key"] = append(m["key"], 1) // 需要先初始化

// 正确做法
if m["key"] == nil {
    m["key"] = make([]int, 0)
}
m["key"] = append(m["key"], 1)
```

#### 性能优化
```go
// 预分配空间提高性能
// 如果你知道大概的大小：
m := make(map[int]int, 1000) // 预分配1000个元素的容量

// 避免频繁的map访问
value := m[key] // 一次访问
if value > 0 {  // 使用局部变量
    // ...
}
// 而不是重复 m[key] > 0
```

### 力扣实战示例

#### 有效的字母异位词
```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    
    count := make(map[rune]int)
    for _, char := range s {
        count[char]++
    }
    for _, char := range t {
        count[char]--
        if count[char] < 0 {
            return false
        }
    }
    return true
}
```

#### 示例2：最长连续序列
```go
func longestConsecutive(nums []int) int {
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    
    longest := 0
    for num := range numSet {
        // 只从序列的起点开始计算
        if !numSet[num-1] {
            currentNum := num
            currentStreak := 1
            
            for numSet[currentNum+1] {
                currentNum++
                currentStreak++
            }
            
            if currentStreak > longest {
                longest = currentStreak
            }
        }
    }
    return longest
}
```

#### 字母异位词分组
```go
func groupAnagrams(strs []string) [][]string {
    groups := make(map[string][]string)
    
    for _, str := range strs {
        // 将字符串转换为字符数组并排序
        chars := []rune(str)
        sort.Slice(chars, func(i, j int) bool {
            return chars[i] < chars[j]
        })
        key := string(chars)
        
        groups[key] = append(groups[key], str)
    }
    
    result := make([][]string, 0, len(groups))
    for _, group := range groups {
        result = append(result, group)
    }
    return result
}
```

### 总结要点

1. **首选数据结构**：需要快速查找、去重、计数时优先考虑哈希表
2. **存在性检查**：使用`value, exists := m[key]`模式
3. **频率统计**：`m[key]++` 是最常用的模式
4. **预分配空间**：使用`make(map[K]V, capacity)`提高性能
5. **注意并发**：map不是并发安全的，需要加锁
6. **遍历无序**：不要依赖map的遍历顺序
7. **零值特性**：利用好零值，但要小心陷阱

# （需回看）删除有序数组中的重复项 II（9.15.4）

## 快慢指针法

这道题可以类比上一道题，区别在于长度，因此对于异常判断、初始位置、前后指针的相差距离这些要做一些改动。直接看的题解默写的，真不知道这思路是怎么想出来的，我感觉启发就是确定好slow和fast的锚定与探索作用，而不是上来就根据实例进行推断

```go
func removeDuplicates(nums []int) int {
    length=len(nums)
    //如果长度小于等于2，不需要进行任何处理就是正确结果
    if length<=2{
        return length
    }
    //设置快慢指针 但是起始位置
    slow, fast := 2, 2
    for fast<n{
        if nums[slow-2]!=nums[fast]{
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }
    return slow        
}
```

## for循环的使用技巧

好的！为您全面总结Go语言中`for`循环在力扣题目中的使用要点和技巧：

### for循环的四种基本形式

#### 1. 传统三段式（最常用）
```go
for 初始化; 条件; 后置操作 {
    // 循环体
}
```

**示例：**
```go
for i := 0; i < 5; i++ {
    fmt.Println(i) // 输出: 0,1,2,3,4
}
```

#### 2. while风格（条件循环）
```go
for 条件 {
    // 循环体
}
```

**示例：**
```go
count := 5
for count > 0 {
    fmt.Println(count) // 输出: 5,4,3,2,1
    count--
}
```

#### 3. 无限循环
```go
for {
    // 循环体，需要break退出
    if 退出条件 {
        break
    }
}
```

**示例：**
```go
for {
    fmt.Println("循环中...")
    time.Sleep(1 * time.Second)
    break // 实际使用时需要合理的退出条件
}
```

#### 4. range循环（遍历集合）
```go
for 索引, 值 := range 集合 {
    // 循环体
}
```

**示例：**
```go
nums := []int{1, 2, 3}
for i, num := range nums {
    fmt.Printf("索引:%d, 值:%d\n", i, num)
}
```

### 力扣常用for循环模式

#### 1. 数组/切片遍历
```go
// 方式1：使用range（只读场景）
for i, num := range nums {
    // i: 索引, num: 值（副本）
}

// 方式2：使用索引（需要修改原数组）
for i := 0; i < len(nums); i++ {
    nums[i] = nums[i] * 2 // 修改原数组
}

// 方式3：从特定位置开始
for i := 1; i < len(nums); i++ { // 从第2个元素开始
    // ...
}
```

#### 2. 双指针技巧
```go
// 左右指针
left, right := 0, len(nums)-1
for left < right {
    // 处理逻辑
    left++
    right--
}

// 快慢指针
slow, fast := 0, 0
for fast < len(nums) {
    if 条件 {
        nums[slow] = nums[fast]
        slow++
    }
    fast++
}
```

#### 3. 矩阵遍历
```go
// 二维数组遍历
matrix := [][]int{{1,2,3}, {4,5,6}}
for i := 0; i < len(matrix); i++ {
    for j := 0; j < len(matrix[i]); j++ {
        fmt.Print(matrix[i][j], " ")
    }
    fmt.Println()
}

// 螺旋矩阵遍历
top, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1
for top <= bottom && left <= right {
    // 遍历四个方向
}
```

#### 4. 链表操作
```go
// 链表遍历
for curr != nil {
    // 处理当前节点
    curr = curr.Next
}

// 寻找链表中点
slow, fast := head, head
for fast != nil && fast.Next != nil {
    slow = slow.Next
    fast = fast.Next.Next
}
```

### 循环控制语句

#### 1. break - 跳出循环
```go
for i := 0; i < 10; i++ {
    if i == 5 {
        break // 当i=5时跳出循环
    }
    fmt.Println(i) // 输出: 0,1,2,3,4
}
```

#### 2. continue - 跳过本次循环
```go
for i := 0; i < 5; i++ {
    if i%2 == 0 {
        continue // 跳过偶数次循环
    }
    fmt.Println(i) // 输出: 1,3
}
```

#### 3. 标签break - 跳出多重循环
```go
outerLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i*j == 4 {
            break outerLoop // 直接跳出外层循环
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
```

### 常见陷阱与最佳实践

#### 1. 索引越界问题
```go
// 错误：可能越界
for i := 0; i <= len(nums); i++ { // 应该用 < 而不是 <=
    fmt.Println(nums[i]) // 当i==len(nums)时越界
}

// 正确：
for i := 0; i < len(nums); i++ {
    fmt.Println(nums[i])
}
```

#### 2. 无限循环预防
```go
// 危险：可能死循环
i := 0
for i < 5 {
    // 忘记 i++，导致无限循环
    fmt.Println(i)
    // 应该加上: i++
}

// 安全：使用三段式
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
```

#### 3. 性能优化
```go
// 较差：每次循环都计算len(nums)
for i := 0; i < len(nums); i++ {
    // len(nums)每次都会调用
}

// 较好：预先计算长度
n := len(nums)
for i := 0; i < n; i++ {
    // 使用预先计算的长度
}

// 最好：使用range（编译器优化）
for i := range nums {
    // 最高效的遍历方式
}
```

#### 4. 修改遍历中的集合
```go
// 危险：在range循环中修改切片长度
nums := []int{1, 2, 3, 4, 5}
for i, num := range nums {
    if num%2 == 0 {
        nums = append(nums[:i], nums[i+1:]...) // 修改原切片，可能导致意外行为
    }
}

// 安全：创建新切片或使用反向遍历
result := []int{}
for _, num := range nums {
    if num%2 != 0 {
        result = append(result, num)
    }
}
```

### 力扣实战示例

#### 示例1：两数之和
```go
func twoSum(nums []int, target int) []int {
    seen := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if idx, exists := seen[complement]; exists {
            return []int{idx, i}
        }
        seen[num] = i
    }
    return nil
}
```

#### 示例2：反转字符串
```go
func reverseString(s []byte) {
    for left, right := 0, len(s)-1; left < right; left, right = left+1, right-1 {
        s[left], s[right] = s[right], s[left]
    }
}
```

#### 示例3：移动零
```go
func moveZeroes(nums []int) {
    slow := 0
    for fast := 0; fast < len(nums); fast++ {
        if nums[fast] != 0 {
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow++
        }
    }
}
```

#### 示例4：二分查找
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

### 总结要点

1. **选择合适的形式**：
   - 知道次数 → 三段式 `for i:=0; i<n; i++`
   - 条件循环 → while风格 `for condition {}`
   - 遍历集合 → range循环 `for i, v := range`

2. **性能优先**：
   - 预先计算循环边界
   - 优先使用range遍历
   - 避免在循环内进行昂贵操作

3. **安全第一**：
   - 检查索引越界
   - 确保循环有退出条件
   - 小心修改正在遍历的集合

4. **掌握控制语句**：
   - `break` 跳出循环
   - `continue` 跳过本次
   - 标签跳出多重循环

掌握这些for循环技巧，您就能高效解决力扣中的各种算法问题！

# 多数元素（9.16.1）









# 轮转数组（9.16.2）









# 买卖股票的最佳时机（9.16.3）







# 买卖股票的最佳时机 II（9.16.4）