# 合并两个有序数组

## 方法1 追加之后排序

这个方法针对无序数组也可以使用

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //使用数组处理方法直接处理
    copy(nums1[m:],nums2)//追加切片
    sort.Ints(nums1)//对整形数组的排序方法
}
```

## 方法2 双指针法

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //创建指针和结果数组
    result := make([]int,0,m+n)//最后赋值给nums1
    p1,p2 := 0,0
    for{
        if p1 == m {
            result = append(result , nums2[p2:]...)
            break
        }
        if p2 == n {
            result = append(result , nums1[p1:]...)
            break
        }  
        if nums1[p1]<nums2[p2] {
            result = append(result , nums1[p1])
            p1++
            continue
        }else {
            result = append(result , nums2[p2])
            p2++
            continue
        }
    }
    copy(nums1,result)
}    
```

## 知识点

### append方法

#### 追加单个元素

```go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4)  // [1, 2, 3, 4]
```

#### 追加多个元素

```go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4, 5, 6)  // [1, 2, 3, 4, 5, 6]
```

#### 追加另一个切片

```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}
slice1 = append(slice1, slice2...)  // [1, 2, 3, 4, 5, 6]
```

#### 下面内容了解一下即可

**重要特性**

1. **自动扩容**：当切片容量不足时，`append` 会自动分配一个新的底层数组，通常是原容量的2倍（当长度小于1024时）。

2. **返回值**：`append` 总是返回一个新的切片，必须将返回值赋给原切片变量。

3. **零值切片**：可以向 `nil` 切片追加元素：

   ```go
   var s []int
   s = append(s, 1)  // [1]
   ```

**性能考虑**

- 频繁的 `append` 操作可能导致多次内存分配和复制

- 如果知道最终大小，可以预先分配容量：

  ```go
  s := make([]int, 0, 100)  // 长度为0，容量为100
  ```

**常见错误**

```go
s := []int{1, 2, 3}
_ = append(s, 4)  // 错误：没有使用返回值
// s 仍然是 [1, 2, 3]
```

`append` 是 Go 中处理动态数组增长的主要方式，理解它的工作原理对于编写高效的 Go 代码非常重要。

### copy方法

`copy` 是 Go 语言中用于复制切片内容的内置函数，常用于将一个切片的内容复制到另一个切片中。

```go
copy(dst, src []T) int
```

- 返回实际复制的元素个数（取 dst 和 src 长度的较小值）

#### 用法

```go
nums1 := make([]int, 10)  // 假设 nums1 有足够容量
nums2 := []int{4, 5, 6}
m := 5  // 从 nums1 的第 m 个位置开始复制

n := copy(nums1[m:], nums2)  // 将 nums2 复制到 nums1[m:] 的位置
// n 是实际复制的元素数
```

#### 以下内容了解一下即可

1. 不会自动扩容，目标切片必须有足够空间
2. 可以部分复制（取决于目标切片的剩余空间）
3. 常用于合并切片或覆盖切片部分内容

**示例：合并两个有序切片**

```go
nums1 := make([]int, len(nums1Original)+len(nums2)
copy(nums1, nums1Original)
copy(nums1[len(nums1Original):], nums2)
```

### sort包

`sort` 包是 Go 标准库中用于排序和搜索的包，提供了对切片和用户定义集合进行排序的功能。

#### 基本类型排序方法

1. 整型排序

```go
func Ints(x []int)                  // 对 int 切片进行升序排序
func IntsAreSorted(x []int) bool    // 检查 int 切片是否已排序
```

2. 浮点数排序

```go
func Float64s(x []float64)          // 对 float64 切片进行升序排序
func Float64sAreSorted(x []float64) bool  // 检查 float64 切片是否已排序
```

3. 字符串排序

```go
func Strings(x []string)            // 对 string 切片进行升序排序(按字典序)
func StringsAreSorted(x []string) bool  // 检查 string 切片是否已排序
```

#### 通用排序接口

1. Slice 排序 (Go 1.8+)

```go
func Slice(x interface{}, less func(i, j int) bool)  // 根据 less 函数对切片排序
func SliceStable(x interface{}, less func(i, j int) bool)  // 稳定排序
func SliceIsSorted(x interface{}, less func(i, j int) bool) bool  // 检查是否已排序
```

2. 自定义排序接口

```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
func Sort(data Interface)          // 排序
func Stable(data Interface)       // 稳定排序
func IsSorted(data Interface) bool // 检查是否已排序
```

#### 搜索方法

```go
func SearchInts(a []int, x int) int      // 在已排序的 int 切片中搜索 x
func SearchFloat64s(a []float64, x float64) int  // 在已排序的 float64 切片中搜索
func SearchStrings(a []string, x string) int  // 在已排序的 string 切片中搜索
func Search(n int, f func(int) bool) int  // 通用二分搜索
```

#### 逆序排序

Go 1.21+ 引入了新的逆序排序方式：
```go
// 对整型切片降序排序
sort.Sort(sort.Reverse(sort.IntSlice(nums)))

// Go 1.21+ 更简洁的方式
slices.SortFunc(nums, func(a, b int) int {
    return b - a  // 降序排序
})
```

#### 实用示例

1. 自定义结构体排序

```go
type Person struct {
    Name string
    Age  int
}

people := []Person{
    {"Alice", 25},
    {"Bob", 20},
}

// 按年龄排序
sort.Slice(people, func(i, j int) bool {
    return people[i].Age < people[j].Age
})
```

2. 搜索示例

```go
nums := []int{1, 3, 5, 7, 9}
x := 5
pos := sort.SearchInts(nums, x)  // 返回 2
```

3. 检查切片是否已排序

```go
if sort.IntsAreSorted(nums) {
    fmt.Println("切片已排序")
}
```

#### 性能提示

1. 对于基本类型，优先使用 `sort.Ints` 等特定函数，它们比通用 `sort.Slice` 更快
2. 需要保持相等元素原始顺序时，使用 `Stable` 系列方法
3. 对大型数据集，考虑使用 `sort.Slice` 而非实现 `sort.Interface` 接口，代码更简洁
4. `sort` 包提供了强大而灵活的排序功能，是 Go 语言中处理有序数据的核心工具之一。

# 移除元素