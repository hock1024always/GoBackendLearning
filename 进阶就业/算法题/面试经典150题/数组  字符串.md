# 合并两个有序数组（9.15.1）

## 方法1 追加之后排序

这个方法针对无序数组也可以使用

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //使用数组处理方法直接处理
    copy(nums1[m:],nums2)//追加切片
    sort.Ints(nums1)//对整形数组的排序方法
}
```

## 方法2 双指针法

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //创建结果数组并且进行赋值
    result := make([]int,0,m+n)
    //创建左右指针
    p1 := 0
    p2 := 0
    //赋值
    for {
        //防止nums中有空切片  并且顺带可以简化for循环
        if p1==m{
            result=append(result,nums2[p2:]...)
            break
        }
        if p2==n{
            result=append(result,nums1[p1:]...)
            break
        } 

        if nums1[p1]>=nums2[p2]{
            result = append(result,nums2[p2])
            p2++
            continue
        }else{
            result = append(result,nums1[p1])
            p1++
            continue
        }
    }
    copy(nums1,result)
}    
```

### 注意

```go
result := make([]int,m+n)//这样写再加上append方法，会造成前面m+n个元素全为0
```

## 知识点

### make方法

`make` 是 Go 语言中用于**初始化内建引用类型（slice、map、channel）** 的函数，它**分配内存并初始化**相应的数据结构，返回的是类型本身（而不是指针）。

#### 用于切片 (Slice) - *力扣最常用*

切片是动态数组，是解决数组类题目的核心数据结构。

**语法：**

```go
// 语法1: 指定长度和容量
slice := make([]T, length, capacity)

// 语法2: 省略容量，则长度 == 容量
slice := make([]T, length)
```
*   `T`: 切片元素的类型 (如 `int`, `string`, `byte`)
*   `length`: 切片的**当前长度**（已有元素个数）
*   `capacity`: 切片的**总容量**（底层数组能容纳的元素个数）

**力扣实战技巧：**

1.  **预分配内存以避免频繁扩容**：这是最重要的性能优化点。如果你能预估结果切片的大致大小，使用 `make` 预先分配足够的 `capacity` 可以避免 `append` 操作时底层数组的多次重新分配和拷贝，极大提升性能。
    
    *   **例子 (力扣 509. 斐波那契数)**：你知道要计算前 N 个斐波那契数。
        ```go
        func fib(n int) int {
            if n <= 1 {
                return n
            }
            // 预分配一个长度为 n+1 的切片，避免后续 append 的扩容开销
            dp := make([]int, n+1)
            dp[0], dp[1] = 0, 1
            for i := 2; i <= n; i++ {
                dp[i] = dp[i-1] + dp[i-2]
            }
            return dp[n]
        }
        ```
    
2.  **创建空切片但有容量**：当你需要一个初始为空的切片，但又知道即将添加大量元素时。
    *   **例子**：收集二叉树遍历的结果。
        ```go
        // 假设你知道树节点大约有1000个
        result := make([]int, 0, 1000)
        // 然后使用 result = append(result, value) 添加元素，效率极高
        ```

3.  **创建具有初始长度的切片**：当你需要直接通过索引 `dp[i]` 赋值，而不是使用 `append` 时，必须指定足够的 `length`。
    *   **动态规划 (DP) 问题**：几乎所有的 DP 题都需要先创建一个 `dp` 数组（切片）。
        ```go
        // 力扣 70. 爬楼梯
        func climbStairs(n int) int {
            if n <= 2 {
                return n
            }
            dp := make([]int, n+1) // 创建长度为 n+1 的切片
            dp[1] = 1
            dp[2] = 2
            for i := 3; i <= n; i++ {
                dp[i] = dp[i-1] + dp[i-2] // 直接按索引赋值
            }
            return dp[n]
        }
        ```

#### 用于映射 (Map) - *也很常用*

Map 用于存储键值对，解决需要快速查找、计数的题目。

**语法：**

```go
m := make(map[KeyType]ValueType)
m := make(map[KeyType]ValueType, initialCapacity) // 推荐指定初始容量
```
*   `initialCapacity`: 提示 Go 运行时预先分配大约能存储 `initialCapacity` 个元素的空间。**虽然不是严格的限制，但指定一个合理的值可以避免初期的内存重整，提升性能。**

**力扣实战技巧：**

1.  **用于计数**：统计元素出现的频率。
    *   **例子 (力扣 1. 两数之和)**：虽然最优解是一遍哈希，但也能体现 map 的创建。
        ```go
        func twoSum(nums []int, target int) []int {
            // 创建一个map，key是数字，value是索引
            numMap := make(map[int]int, len(nums)) // 建议指定容量为nums的长度
            for i, num := range nums {
                complement := target - num
                if idx, ok := numMap[complement]; ok {
                    return []int{idx, i}
                }
                numMap[num] = i
            }
            return nil
        }
        ```

2.  **用于记录状态**：记录访问过的节点或状态，避免重复处理（如图的遍历、回溯算法）。
    *   **例子**：克隆图（力扣 133）、避免回溯中的重复选择。

#### 用于通道 (Channel) - *并发题目中使用*

Channel 用于 goroutine 之间的通信，在并发类的题目中可能会用到。

**语法：**

```go
ch := make(chan T)    // 无缓冲通道
ch := make(chan T, n) // 带缓冲通道，缓冲区大小为 n
```
*   在力扣的算法题中，单纯使用 channel 的情况较少，除非题目明确要求并发。

#### 总结与对比 (`make` vs `new`)

| 特性         | `make`                                                       | `new`                                                        |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **适用类型** | 仅用于内建引用类型：`slice`, `map`, `channel`                | 用于任何类型（包括值类型和自定义结构体）                     |
| **返回值**   | **类型 T 本身** (e.g., `[]int`, `map[int]int`)               | **指向该类型的指针** (`*T`)                                  |
| **初始化**   | **会初始化**内存（置零值），并设置好内部数据结构（如 slice 的 len/cap） | **只分配内存**，并将内存置为零值（`nil` for references, `0` for numbers, `""` for strings），返回指向这块零值内存的指针 |

**错误示例：**
```go
var s *[]int = new([]int) // s 现在是一个指向 nil 切片的指针
*s = make([]int, 10)      // 必须这样使用：先 new 出一个指针，再让指针指向 make 出来的切片
// 通常我们直接写更简单： s := make([]int, 10)
```

#### 力扣题刷技巧

1.  **看到数组、字符串、动态规划题**：第一反应想到 `make([]T, len, cap)` 来创建你的切片（DP 表、结果集）。
2.  **看到需要查找、去重、计数的题**：第一反应想到 `make(map[K]V)` 来创建你的映射。
3.  **养成预分配容量的习惯**：在知道或能估算数据规模时，始终为 `make` 函数指定 `capacity` 参数。这是一个简单且有效的性能优化手段，能让你的解法跑得更快。

### append方法

#### 追加单个元素

```go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4)  // [1, 2, 3, 4]
```

#### 追加多个元素

```go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4, 5, 6)  // [1, 2, 3, 4, 5, 6]
```

#### 追加另一个切片

```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}
slice1 = append(slice1, slice2...)  // [1, 2, 3, 4, 5, 6]
```

#### 下面内容了解一下即可

**重要特性**

1. **自动扩容**：当切片容量不足时，`append` 会自动分配一个新的底层数组，通常是原容量的2倍（当长度小于1024时）。

2. **返回值**：`append` 总是返回一个新的切片，必须将返回值赋给原切片变量。

3. **零值切片**：可以向 `nil` 切片追加元素：

   ```go
   var s []int
   s = append(s, 1)  // [1]
   ```

**性能考虑**

- 频繁的 `append` 操作可能导致多次内存分配和复制

- 如果知道最终大小，可以预先分配容量：

  ```go
  s := make([]int, 0, 100)  // 长度为0，容量为100
  ```

**常见错误**

```go
s := []int{1, 2, 3}
_ = append(s, 4)  // 错误：没有使用返回值
// s 仍然是 [1, 2, 3]
```

`append` 是 Go 中处理动态数组增长的主要方式，理解它的工作原理对于编写高效的 Go 代码非常重要。

### copy方法

`copy` 是 Go 语言中用于复制切片内容的内置函数，常用于将一个切片的内容复制到另一个切片中。

```go
copy(dst, src []T) int
```

- 返回实际复制的元素个数（取 dst 和 src 长度的较小值）

#### 用法

```go
nums1 := make([]int, 10)  // 假设 nums1 有足够容量
nums2 := []int{4, 5, 6}
m := 5  // 从 nums1 的第 m 个位置开始复制

n := copy(nums1[m:], nums2)  // 将 nums2 复制到 nums1[m:] 的位置
// n 是实际复制的元素数
```

#### 以下内容了解一下即可

1. 不会自动扩容，目标切片必须有足够空间
2. 可以部分复制（取决于目标切片的剩余空间）
3. 常用于合并切片或覆盖切片部分内容

**示例：合并两个有序切片**

```go
nums1 := make([]int, len(nums1Original)+len(nums2)
copy(nums1, nums1Original)
copy(nums1[len(nums1Original):], nums2)
```

### sort包

`sort` 包是 Go 标准库中用于排序和搜索的包，提供了对切片和用户定义集合进行排序的功能。

#### 基本类型排序方法

1. 整型排序

```go
func Ints(x []int)                  // 对 int 切片进行升序排序
func IntsAreSorted(x []int) bool    // 检查 int 切片是否已排序
```

2. 浮点数排序

```go
func Float64s(x []float64)          // 对 float64 切片进行升序排序
func Float64sAreSorted(x []float64) bool  // 检查 float64 切片是否已排序
```

3. 字符串排序

```go
func Strings(x []string)            // 对 string 切片进行升序排序(按字典序)
func StringsAreSorted(x []string) bool  // 检查 string 切片是否已排序
```

#### 通用排序接口

1. Slice 排序 (Go 1.8+)

```go
func Slice(x interface{}, less func(i, j int) bool)  // 根据 less 函数对切片排序
func SliceStable(x interface{}, less func(i, j int) bool)  // 稳定排序
func SliceIsSorted(x interface{}, less func(i, j int) bool) bool  // 检查是否已排序
```

2. 自定义排序接口

```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
func Sort(data Interface)          // 排序
func Stable(data Interface)       // 稳定排序
func IsSorted(data Interface) bool // 检查是否已排序
```

#### 搜索方法

```go
func SearchInts(a []int, x int) int      // 在已排序的 int 切片中搜索 x
func SearchFloat64s(a []float64, x float64) int  // 在已排序的 float64 切片中搜索
func SearchStrings(a []string, x string) int  // 在已排序的 string 切片中搜索
func Search(n int, f func(int) bool) int  // 通用二分搜索
```

#### 逆序排序

Go 1.21+ 引入了新的逆序排序方式：
```go
// 对整型切片降序排序
sort.Sort(sort.Reverse(sort.IntSlice(nums)))

// Go 1.21+ 更简洁的方式
slices.SortFunc(nums, func(a, b int) int {
    return b - a  // 降序排序
})
```

#### 实用示例

1. 自定义结构体排序

```go
type Person struct {
    Name string
    Age  int
}

people := []Person{
    {"Alice", 25},
    {"Bob", 20},
}

// 按年龄排序
sort.Slice(people, func(i, j int) bool {
    return people[i].Age < people[j].Age
})
```

2. 搜索示例

```go
nums := []int{1, 3, 5, 7, 9}
x := 5
pos := sort.SearchInts(nums, x)  // 返回 2
```

3. 检查切片是否已排序

```go
if sort.IntsAreSorted(nums) {
    fmt.Println("切片已排序")
}
```

#### 性能提示

1. 对于基本类型，优先使用 `sort.Ints` 等特定函数，它们比通用 `sort.Slice` 更快
2. 需要保持相等元素原始顺序时，使用 `Stable` 系列方法
3. 对大型数据集，考虑使用 `sort.Slice` 而非实现 `sort.Interface` 接口，代码更简洁
4. `sort` 包提供了强大而灵活的排序功能，是 Go 语言中处理有序数据的核心工具之一。

# 移除元素（9.15.2）

## 方法1：前后指针法

```go
func removeElement(nums []int, val int) int {
    //创建前后指针以及最终元素个数的记录
    follow := 0
    result := 0
    for front,_ := range nums{
        if nums[front] != val{
            nums[follow]=nums[front]
            result++
            front++
            follow++
        }else{
            front++
        }
    }
    return result
}
```

## 知识点

### 快慢指针写法

```go
func removeElement(nums []int, val int) int {
    slow := 0 // 慢指针，指向下一个要放置非val元素的位置
    
    for fast := 0; fast < len(nums); fast++ {
        if nums[fast] != val {
            nums[slow] = nums[fast]
            slow++
        }
    }
    
    return slow
}
```

### range方法

好的！为您总结Go语言`range`方法在力扣题目中的使用要点，特别针对算法题目的特点：

```go
for index, value := range collection {
    // 循环体
}
```

#### 数组/切片（最常用）

```go
nums := []int{1, 2, 3, 4, 5}

// 方式1：获取索引和值（推荐）
for i, num := range nums {
    fmt.Printf("nums[%d] = %d\n", i, num)
}

// 方式2：只获取值
for _, num := range nums {
    fmt.Printf("值: %d\n", num)
}

// 方式3：只获取索引
for i := range nums {
    fmt.Printf("索引: %d, 值: %d\n", i, nums[i])
}
```

#### 字符串（字符遍历）

```go
s := "hello"

// 遍历字符串（按rune遍历，支持中文）
for i, char := range s {
    fmt.Printf("位置%d: %c (Unicode: %U)\n", i, char, char)
}
```

#### Map（无序遍历）

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}

// 遍历map（顺序随机）
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}
```

#### 力扣题目中的实用技巧

1. 原地修改数组

   ```go
   // 错误：修改的是副本，不影响原数组
   for _, num := range nums {
       num = num * 2  // 无效！
   }
   
   // 正确：通过索引修改原数组
   for i := range nums {
       nums[i] = nums[i] * 2  // 有效！
   }
   ```

2. 双指针技巧中的range

   ```go
   func twoSum(nums []int, target int) []int {
       // 使用range遍历，配合map快速查找
       seen := make(map[int]int)
       for i, num := range nums {
           complement := target - num
           if idx, exists := seen[complement]; exists {
               return []int{idx, i}
           }
           seen[num] = i
       }
       return nil
   }
   ```

3. 字符串处理

   ```go
   func countCharacters(s string) int {
       count := 0
       for _, char := range s {
           if char != ' ' {
               count++
           }
       }
       return count
   }
   ```

4. 矩阵遍历（二维数组）

   ```go
   matrix := [][]int{{1,2,3}, {4,5,6}, {7,8,9}}
   
   // 遍历二维数组
   for i, row := range matrix {
       for j, value := range row {
           fmt.Printf("matrix[%d][%d] = %d\n", i, j, value)
       }
   }
   ```

####  常见陷阱与注意事项

1. 值拷贝问题

   ```go
   nums := []int{1, 2, 3}
   for _, num := range nums {
       num++  // 这只是修改副本，原数组不变！
   }
   // nums仍然是[1, 2, 3]
   ```

2. 性能考虑

   ```go
   // 对于大数组，直接使用索引可能更快
   bigArray := make([]int, 1000000)
   
   // 较慢：每次迭代都有值拷贝
   for _, value := range bigArray {
       _ = value
   }
   
   // 较快：直接通过索引访问
   for i := range bigArray {
       _ = bigArray[i]
   }
   ```

3. 边界情况处理

   ```go
   // 空数组/切片不会panic
   var empty []int
   for i, num := range empty {
       fmt.Println(i, num)  // 不会执行
   }
   
   // nil切片也不会panic
   var nilSlice []int = nil
   for i, num := range nilSlice {
       fmt.Println(i, num)  // 不会执行
   }
   ```

#### 力扣实战示例

1. 移除元素

   ```go
   func removeElement(nums []int, val int) int {
       slow := 0
       // 使用range遍历，但通过索引修改原数组
       for _, num := range nums {
           if num != val {
               nums[slow] = num
               slow++
           }
       }
       return slow
   }
   ```

2. 反转字符串

   ```go
   func reverseString(s []byte) {
       // 使用range获取索引，进行双指针交换
       for i := range s[:len(s)/2] {
           j := len(s) - 1 - i
           s[i], s[j] = s[j], s[i]
       }
   }
   ```

3. 寻找重复元素

   ```go
   func findDuplicate(nums []int) int {
       seen := make(map[int]bool)
       for _, num := range nums {
           if seen[num] {
               return num
           }
           seen[num] = true
       }
       return -1
   }
   ```

#### 总结

1. **优先使用索引**：在需要修改原数组时，使用`for i := range`形式
2. **值遍历只读**：`for _, value := range`中的value是副本，不能修改原数据
3. **map遍历无序**：不要依赖map的遍历顺序
4. **性能敏感时**：大数组考虑直接使用索引访问
5. **安全遍历**：range对nil和空集合是安全的

# （须回看）删除有序数组中的重复项（9.15.3）

## 快慢指针法

```go
func removeDuplicates(nums []int) int {
    //异常情况
    length:=len(nums)
    if length == 0{
        return 0
    }
    
    //慢指针
    slow := 0

    //快指针起始遍历
    for fast:=1;fast<length;fast++{
        if nums[fast]!=nums[slow]{
            slow++
            nums[slow]=nums[fast]
        }
    }

    return slow+1
}
```

### 注意1

下面这段代码存在问题：

对于输入 `[1,1,2]`，当 `fast = 1`（指向第二个1）时：

- `nums[fast] == nums[fast+1]` → `1 == 2` → false
- 进入 `else` 分支：`fast++` → `fast = 2`
- 现在 `fast = 2`，但数组长度是3（索引0,1,2）
- 下一次循环：`if fast == length-1` → `2 == 2`，应该跳出循环

**但是**，如果数组是 `[1,1,1]`：

- 内层循环会一直 `fast++`，直到 `fast = 2`
- 然后检查 `nums[2] != nums[3]` → 访问 `nums[3]` 导致越界

```go
func removeDuplicates(nums []int) int {
    //慢指针
    fast,slow := 0,0
    length := len(nums)
    
    for {
        //弹出条件
        if fast == length-1{
            break
        }

        if nums[fast]==nums[fast+1]{
            for{
                if nums[fast]!=nums[fast+1]{
                    break
                }
                fast++
            }
            fast++
            slow++
            nums[slow]=nums[fast]
        }else{
            fast++
            slow++
            nums[slow]=nums[fast]
        }

    }
    return slow+1
}
```

### 注意2

```go
return slow++  // 错误！
```

1. **语法错误**：Go 的 `return` 语句不能包含表达式，只能返回值
2. **逻辑错误**：即使语法正确，`slow++` 是后置自增，会先返回 `slow` 的值，然后再自增

因此要写成：

```go
return slow+1
```

## 哈希表（如果不是非严格递增就要用到）

### 基本操作

```go
// 创建哈希表
m := make(map[keyType]valueType)

// 字面量初始化
m := map[string]int{"a": 1, "b": 2}

// 基本操作
m["key"] = value      // 插入/更新
value := m["key"]     // 读取
delete(m, "key")      // 删除
len(m)                // 获取大小
```

### 力扣常用哈希表模式

#### 频率统计（最常用）

```go
// 统计元素频率
func countFrequency(nums []int) map[int]int {
    freq := make(map[int]int)
    for _, num := range nums {
        freq[num]++
    }
    return freq
}

// 字符串字符统计
func charCount(s string) map[rune]int {
    count := make(map[rune]int)
    for _, char := range s {
        count[char]++
    }
    return count
}
```

#### 快速查找存在性
```go
// 检查重复元素
func hasDuplicate(nums []int) bool {
    seen := make(map[int]bool)
    for _, num := range nums {
        if seen[num] {
            return true
        }
        seen[num] = true
    }
    return false
}

// 两数之和（经典题目）
func twoSum(nums []int, target int) []int {
    indexMap := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if idx, exists := indexMap[complement]; exists {
            return []int{idx, i}
        }
        indexMap[num] = i
    }
    return nil
}
```

#### 分组归类
```go
// 按某种规则分组
func groupAnagrams(strs []string) [][]string {
    groups := make(map[string][]string)
    for _, str := range strs {
        key := sortString(str) // 对字符串排序作为key
        groups[key] = append(groups[key], str)
    }
    
    result := make([][]string, 0, len(groups))
    for _, group := range groups {
        result = append(result, group)
    }
    return result
}
```

### 高级使用技巧

#### 存在性检查的两种方式

```go
m := map[string]int{"a": 1}

// 方式1：使用双返回值（推荐）
if value, exists := m["key"]; exists {
    // key存在
} else {
    // key不存在
}

// 方式2：使用零值特性（小心陷阱）
value := m["key"] // 不存在的key返回零值
if value != 0 {   // 如果0是有效值，这会出错！
    // ...
}
```

#### 默认值处理
```go
// 安全的计数器模式
func safeIncrement(m map[string]int, key string) {
    if _, exists := m[key]; !exists {
        m[key] = 0 // 初始化
    }
    m[key]++
}

// 或者使用一行代码
m[key] = m[key] + 1 // 如果key不存在，m[key]返回0
```

#### 遍历技巧
```go
m := map[int]string{1: "a", 2: "b", 3: "c"}

// 遍历键值对（顺序随机！）
for key, value := range m {
    fmt.Printf("%d: %s\n", key, value)
}

// 只遍历键
for key := range m {
    fmt.Println(key)
}

// 只遍历值
for _, value := range m {
    fmt.Println(value)
}
```

### 常见陷阱与注意事项

#### 并发安全问题
```go
// 错误：并发读写map
go func() { m["a"] = 1 }()
go func() { _ = m["a"] }() // 可能panic!

// 解决方案：使用sync.Map或互斥锁
var mu sync.Mutex
mu.Lock()
m["a"] = 1
mu.Unlock()
```

#### 引用类型陷阱
```go
// map的值是引用类型时要注意
m := make(map[string][]int)
m["key"] = append(m["key"], 1) // 需要先初始化

// 正确做法
if m["key"] == nil {
    m["key"] = make([]int, 0)
}
m["key"] = append(m["key"], 1)
```

#### 性能优化
```go
// 预分配空间提高性能
// 如果你知道大概的大小：
m := make(map[int]int, 1000) // 预分配1000个元素的容量

// 避免频繁的map访问
value := m[key] // 一次访问
if value > 0 {  // 使用局部变量
    // ...
}
// 而不是重复 m[key] > 0
```

### 力扣实战示例

#### 有效的字母异位词
```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    
    count := make(map[rune]int)
    for _, char := range s {
        count[char]++
    }
    for _, char := range t {
        count[char]--
        if count[char] < 0 {
            return false
        }
    }
    return true
}
```

#### 示例2：最长连续序列
```go
func longestConsecutive(nums []int) int {
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    
    longest := 0
    for num := range numSet {
        // 只从序列的起点开始计算
        if !numSet[num-1] {
            currentNum := num
            currentStreak := 1
            
            for numSet[currentNum+1] {
                currentNum++
                currentStreak++
            }
            
            if currentStreak > longest {
                longest = currentStreak
            }
        }
    }
    return longest
}
```

#### 字母异位词分组
```go
func groupAnagrams(strs []string) [][]string {
    groups := make(map[string][]string)
    
    for _, str := range strs {
        // 将字符串转换为字符数组并排序
        chars := []rune(str)
        sort.Slice(chars, func(i, j int) bool {
            return chars[i] < chars[j]
        })
        key := string(chars)
        
        groups[key] = append(groups[key], str)
    }
    
    result := make([][]string, 0, len(groups))
    for _, group := range groups {
        result = append(result, group)
    }
    return result
}
```

### 总结要点

1. **首选数据结构**：需要快速查找、去重、计数时优先考虑哈希表
2. **存在性检查**：使用`value, exists := m[key]`模式
3. **频率统计**：`m[key]++` 是最常用的模式
4. **预分配空间**：使用`make(map[K]V, capacity)`提高性能
5. **注意并发**：map不是并发安全的，需要加锁
6. **遍历无序**：不要依赖map的遍历顺序
7. **零值特性**：利用好零值，但要小心陷阱

# （需回看）删除有序数组中的重复项 II（9.15.4）

## 快慢指针法

这道题可以类比上一道题，区别在于长度，因此对于异常判断、初始位置、前后指针的相差距离这些要做一些改动。直接看的题解默写的，真不知道这思路是怎么想出来的，我感觉启发就是确定好slow和fast的锚定与探索作用，而不是上来就根据实例进行推断

```go
func removeDuplicates(nums []int) int {
    length:=len(nums)
    //如果长度小于等于2，不需要进行任何处理就是正确结果
    if length<=2{
        return length
    }
    //设置快慢指针 但是起始位置
    slow, fast := 2, 2
    for fast < length{
        if nums[slow-2]!=nums[fast]{
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }
    return slow        
}
```

## for循环的使用技巧

好的！为您全面总结Go语言中`for`循环在力扣题目中的使用要点和技巧：

### for循环的四种基本形式

#### 1. 传统三段式（最常用）
```go
for 初始化; 条件; 后置操作 {
    // 循环体
}
```

**示例：**
```go
for i := 0; i < 5; i++ {
    fmt.Println(i) // 输出: 0,1,2,3,4
}
```

#### 2. while风格（条件循环）
```go
for 条件 {
    // 循环体
}
```

**示例：**
```go
count := 5
for count > 0 {
    fmt.Println(count) // 输出: 5,4,3,2,1
    count--
}
```

#### 3. 无限循环
```go
for {
    // 循环体，需要break退出
    if 退出条件 {
        break
    }
}
```

**示例：**
```go
for {
    fmt.Println("循环中...")
    time.Sleep(1 * time.Second)
    break // 实际使用时需要合理的退出条件
}
```

#### 4. range循环（遍历集合）
```go
for 索引, 值 := range 集合 {
    // 循环体
}
```

**示例：**
```go
nums := []int{1, 2, 3}
for i, num := range nums {
    fmt.Printf("索引:%d, 值:%d\n", i, num)
}
```

### 力扣常用for循环模式

#### 1. 数组/切片遍历
```go
// 方式1：使用range（只读场景）
for i, num := range nums {
    // i: 索引, num: 值（副本）
}

// 方式2：使用索引（需要修改原数组）
for i := 0; i < len(nums); i++ {
    nums[i] = nums[i] * 2 // 修改原数组
}

// 方式3：从特定位置开始
for i := 1; i < len(nums); i++ { // 从第2个元素开始
    // ...
}
```

#### 2. 双指针技巧
```go
// 左右指针
left, right := 0, len(nums)-1
for left < right {
    // 处理逻辑
    left++
    right--
}

// 快慢指针
slow, fast := 0, 0
for fast < len(nums) {
    if 条件 {
        nums[slow] = nums[fast]
        slow++
    }
    fast++
}
```

#### 3. 矩阵遍历
```go
// 二维数组遍历
matrix := [][]int{{1,2,3}, {4,5,6}}
for i := 0; i < len(matrix); i++ {
    for j := 0; j < len(matrix[i]); j++ {
        fmt.Print(matrix[i][j], " ")
    }
    fmt.Println()
}

// 螺旋矩阵遍历
top, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1
for top <= bottom && left <= right {
    // 遍历四个方向
}
```

#### 4. 链表操作
```go
// 链表遍历
for curr != nil {
    // 处理当前节点
    curr = curr.Next
}

// 寻找链表中点
slow, fast := head, head
for fast != nil && fast.Next != nil {
    slow = slow.Next
    fast = fast.Next.Next
}
```

### 循环控制语句

#### 1. break - 跳出循环
```go
for i := 0; i < 10; i++ {
    if i == 5 {
        break // 当i=5时跳出循环
    }
    fmt.Println(i) // 输出: 0,1,2,3,4
}
```

#### 2. continue - 跳过本次循环
```go
for i := 0; i < 5; i++ {
    if i%2 == 0 {
        continue // 跳过偶数次循环
    }
    fmt.Println(i) // 输出: 1,3
}
```

#### 3. 标签break - 跳出多重循环
```go
outerLoop:
for i := 0; i < 3; i++ {
    for j := 0; j < 3; j++ {
        if i*j == 4 {
            break outerLoop // 直接跳出外层循环
        }
        fmt.Printf("i=%d, j=%d\n", i, j)
    }
}
```

### 常见陷阱与最佳实践

#### 1. 索引越界问题
```go
// 错误：可能越界
for i := 0; i <= len(nums); i++ { // 应该用 < 而不是 <=
    fmt.Println(nums[i]) // 当i==len(nums)时越界
}

// 正确：
for i := 0; i < len(nums); i++ {
    fmt.Println(nums[i])
}
```

#### 2. 无限循环预防
```go
// 危险：可能死循环
i := 0
for i < 5 {
    // 忘记 i++，导致无限循环
    fmt.Println(i)
    // 应该加上: i++
}

// 安全：使用三段式
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
```

#### 3. 性能优化
```go
// 较差：每次循环都计算len(nums)
for i := 0; i < len(nums); i++ {
    // len(nums)每次都会调用
}

// 较好：预先计算长度
n := len(nums)
for i := 0; i < n; i++ {
    // 使用预先计算的长度
}

// 最好：使用range（编译器优化）
for i := range nums {
    // 最高效的遍历方式
}
```

#### 4. 修改遍历中的集合
```go
// 危险：在range循环中修改切片长度
nums := []int{1, 2, 3, 4, 5}
for i, num := range nums {
    if num%2 == 0 {
        nums = append(nums[:i], nums[i+1:]...) // 修改原切片，可能导致意外行为
    }
}

// 安全：创建新切片或使用反向遍历
result := []int{}
for _, num := range nums {
    if num%2 != 0 {
        result = append(result, num)
    }
}
```

### 力扣实战示例

#### 示例1：两数之和
```go
func twoSum(nums []int, target int) []int {
    seen := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if idx, exists := seen[complement]; exists {
            return []int{idx, i}
        }
        seen[num] = i
    }
    return nil
}
```

#### 示例2：反转字符串
```go
func reverseString(s []byte) {
    for left, right := 0, len(s)-1; left < right; left, right = left+1, right-1 {
        s[left], s[right] = s[right], s[left]
    }
}
```

#### 示例3：移动零
```go
func moveZeroes(nums []int) {
    slow := 0
    for fast := 0; fast < len(nums); fast++ {
        if nums[fast] != 0 {
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow++
        }
    }
}
```

#### 示例4：二分查找
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

### 总结要点

1. **选择合适的形式**：
   - 知道次数 → 三段式 `for i:=0; i<n; i++`
   - 条件循环 → while风格 `for condition {}`
   - 遍历集合 → range循环 `for i, v := range`

2. **性能优先**：
   - 预先计算循环边界
   - 优先使用range遍历
   - 避免在循环内进行昂贵操作

3. **安全第一**：
   - 检查索引越界
   - 确保循环有退出条件
   - 小心修改正在遍历的集合

4. **掌握控制语句**：
   - `break` 跳出循环
   - `continue` 跳过本次
   - 标签跳出多重循环

# 多数元素（9.16.1）

## 使用哈希表求解

```go
func majorityElement(nums []int) int {
    //求出目标出现次数
    target := len(nums)/2
    //使用哈希表来计次
    counter := make(map[int]int)
    for _,val := range nums{
        //处理键不存在的情况
        if _,ok := counter[val];!ok{
            counter[val]=1//注意这个是直等
        }else{
            counter[val]++
        }
    }
    //检查计次结果并且输出最终值
    for key,value := range counter{
        if value > target{
            return key
        }
    }
    return 0
}
```

### 注意

这段逻辑中if的判断条很容易搞反

```go
if _,ok := counter[val];!ok{
            counter[val]=1//注意这个是直等
        }else{
            counter[val]++
        }
```

## if语句用法总结

### 1. 基础if-else结构
```go
if condition {
    // 条件为true时执行
} else {
    // 条件为false时执行
}
```

**力扣应用场景**：二分查找、条件判断

```go
// 示例：判断数字正负
if num > 0 {
    return "positive"
} else {
    return "non-positive"
}
```

### 2. if带初始化语句
```go
if statement; condition {
    // 作用域仅限于if块内
}
```

**力扣常见用法**：
```go
// 示例1：map键存在性检查（您的题目中的情况）
if _, ok := counter[val]; ok {
    counter[val]++  // 键存在
} else {
    counter[val] = 1 // 键不存在
}

// 示例2：错误处理
if err := doSomething(); err != nil {
    return err
}

// 示例3：循环中的条件判断
for i := 0; i < n; i++ {
    if val := nums[i]; val > max {
        max = val
    }
}
```

### 3. 多条件判断
```go
if condition1 {
    // ...
} else if condition2 {
    // ...
} else {
    // ...
}
```

**力扣应用场景**：复杂条件分支
```go
// 示例：判断数字特性
if num == 0 {
    return "zero"
} else if num % 2 == 0 {
    return "even"
} else {
    return "odd"
}
```

### 4. 嵌套if语句
```go
if condition1 {
    if condition2 {
        // 两个条件都满足
    }
}
```

### 5. 特殊用法技巧

#### 5.1 简化map操作
```go
// 不需要检查键是否存在，直接++
counter := make(map[int]int)
for _, val := range nums {
    counter[val]++ // 自动处理键不存在的情况
}
```

#### 5.2 提前返回（Guard Clause）
```go
func process(nums []int) error {
    if len(nums) == 0 {
        return errors.New("empty slice")
    }
    if nums[0] < 0 {
        return errors.New("invalid value")
    }
    // 主要逻辑...
    return nil
}
```

#### 5.3 链式条件判断
```go
// 判断数组是否有序
if len(nums) <= 1 {
    return true
}
if nums[0] <= nums[1] && nums[1] <= nums[2] {
    // 升序检查
}
```

### 6. 力扣刷题实用模式

#### 模式1：边界检查优先
```go
func example(nums []int, index int) int {
    if index < 0 || index >= len(nums) {
        return -1 // 越界处理
    }
    return nums[index]
}
```

#### 模式2：双指针条件判断
```go
func twoSum(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    for left < right {
        sum := nums[left] + nums[right]
        if sum == target {
            return []int{left, right}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return nil
}
```

#### 模式3：递归终止条件
```go
func dfs(node *TreeNode, target int) bool {
    if node == nil {
        return false
    }
    if node.Val == target {
        return true
    }
    return dfs(node.Left, target) || dfs(node.Right, target)
}
```

### 7. 常见错误及避免方法

#### 错误1：混淆赋值(=)和比较(==)
```go
// 错误
if x = 5 { ... }   // 编译错误
// 正确
if x == 5 { ... }
```

#### 错误2：作用域混淆
```go
// 错误：val在if外不可用
if val := getValue(); val > 0 {
    // ...
}
fmt.Println(val) // 错误：val未定义

// 正确：提前声明
var val int
if val = getValue(); val > 0 {
    // ...
}
fmt.Println(val) // 正确
```

### 8. 性能优化建议

1. **将最常见条件放在前面**，减少不必要的判断
2. **避免深层嵌套**，使用提前返回模式
3. **合并相关条件**，减少判断次数
4. **利用短路求值**特性：`if condition1 && condition2`

```go
// 优化前
if i < len(nums) {
    if nums[i] == target {
        return i
    }
}

// 优化后
if i < len(nums) && nums[i] == target {
    return i
}
```

# 轮转数组（9.16.2）

## 除余赋值法

```go
func rotate(nums []int, k int)  {
    //创建工具数组之后再赋值回去
    length := len(nums)
    tools := make([]int,length)//可以回去对比一下合并两个有序数组
    //遍历赋值
    for i,val := range nums{
        //计算新位置
        tools[(k+i)%length]=val
    }
    copy(nums,tools)
}
```

### 注意

我们在这个题目中创建数组的方法是有别于切片的

```go
tools := make([]int,length)//定长数组的创建 用于直接对元素赋值

result := make([]int,0,m+n)//定容0长切片的创建 用于append
```

如果想深入了解的话看一下下面的知识点总结

## 数组与切片创建方法对比

### 1. 数组 vs 切片的核心区别

| 特性           | 数组             | 切片                     |
| -------------- | ---------------- | ------------------------ |
| **声明方式**   | `var arr [n]T`   | `var slice []T`          |
| **长度**       | 固定，编译时确定 | 动态，运行时可变         |
| **内存分配**   | 栈或静态存储     | 堆分配（底层引用数组）   |
| **传递方式**   | 值传递（拷贝）   | 引用传递（共享底层数组） |
| **长度表达式** | 必须是常量       | 可以是变量或表达式       |

### 2. 创建方式对比

#### 2.1 数组创建方式
```go
// 方式1：声明并初始化
var arr1 [5]int = [5]int{1, 2, 3, 4, 5}

// 方式2：简短声明
arr2 := [3]string{"a", "b", "c"}

// 方式3：自动长度推断
arr3 := [...]int{1, 2, 3, 4, 5} // 编译器推断长度为5

// 方式4：指定索引初始化
arr4 := [5]int{0: 10, 3: 40} // [10, 0, 0, 40, 0]
```

#### 2.2 切片创建方式
```go
// 方式1：make函数创建（您的rotate函数中使用的方式）
slice1 := make([]int, length)     // 长度=容量
slice2 := make([]int, length, cap)// 指定长度和容量

// 方式2：字面量创建
slice3 := []int{1, 2, 3, 4, 5}

// 方式3：从数组或切片创建
arr := [5]int{1, 2, 3, 4, 5}
slice4 := arr[1:4] // [2, 3, 4]

// 方式4：从现有切片创建（您的merge函数中使用的方式）
slice5 := make([]int, 0)        // 空切片
slice6 := make([]int, 0, m+n)   // 预分配容量（推荐）
```

### 3. 代码分析

#### 3.1 rotate函数中的切片创建
```go
tools := make([]int, length) // 正确用法
```
- **优点**：预分配了确切长度的切片，避免后续append的内存重新分配
- **适用场景**：已知确切长度，需要直接通过索引赋值

#### 3.2 merge函数中的切片创建
```go
result := make([]int, 0, m+n) // 更优的写法
```
- **优化建议**：使用预分配容量，避免append时的多次内存分配
- **当前问题**：`make([]int, 0, m+n)`比`make([]int, 0)`更高效

### 4. 力扣刷题中的选择策略

#### 4.1 选择数组的情况
```go
// 当数据大小固定且已知时
func fixedSizeProblem() {
    const size = 100
    var cache [size]int // 使用数组
    // ...
}
```

#### 4.2 选择切片的情况（更常见）
```go
// 动态大小问题
func dynamicSizeProblem(input []int) {
    // 方式1：已知确切长度
    result := make([]int, len(input))
    
    // 方式2：需要逐步添加元素
    result := make([]int, 0, len(input)*2) // 预分配足够容量
    
    // 方式3：不确定最终大小
    var result []int // 初始为nil切片
}
```

### 5. 性能优化技巧

#### 5.1 预分配容量（最重要）
```go
// 不好：可能多次重新分配内存
result := []int{}
for i := 0; i < 1000; i++ {
    result = append(result, i)
}

// 好：一次性分配足够容量
result := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    result = append(result, i)
}
```

#### 5.2 避免不必要的拷贝
```go
// 直接操作原切片（如果允许修改）
func inPlaceModification(nums []int) {
    for i := range nums {
        nums[i] *= 2
    }
}

// 需要新切片时才创建
func needNewSlice(nums []int) []int {
    result := make([]int, len(nums))
    copy(result, nums)
    // 修改result...
    return result
}
```

### 6. 常见错误及避免

#### 错误1：切片共享底层数组
```go
// 错误：修改slice2会影响slice1
slice1 := []int{1, 2, 3, 4, 5}
slice2 := slice1[1:4]
slice2[0] = 999 // slice1也变为[1, 999, 3, 4, 5]

// 正确：需要独立拷贝时
slice2 := make([]int, len(slice1[1:4]))
copy(slice2, slice1[1:4])
```

#### 错误2：未预分配导致性能问题
```go
// 在循环中append没有预分配容量
// 可能导致O(n²)的时间复杂度（由于多次内存重新分配）
```

#### 错误3：混淆长度和容量
```go
// 创建长度为5，容量为10的切片
s := make([]int, 5, 10)
// s[0]到s[4]为0，s[5]到s[9]不可直接访问（需要append）
```

### 7. 实用代码模板

#### 模板1：原地修改
```go
func inPlaceSolution(nums []int) {
    // 直接修改原切片
    for i := range nums {
        // 处理逻辑
    }
}
```

#### 模板2：返回新切片
```go
func newSliceSolution(nums []int) []int {
    // 预分配结果切片
    result := make([]int, len(nums))
    
    // 或者逐步构建
    // result := make([]int, 0, len(nums))
    // for ... {
    //     result = append(result, value)
    // }
    
    return result
}
```

#### 模板3：合并多个切片（如merge函数）
```go
func mergeSlices(slices ...[]int) []int {
    // 计算总长度
    totalLen := 0
    for _, s := range slices {
        totalLen += len(s)
    }
    
    // 预分配结果
    result := make([]int, 0, totalLen)
    
    // 合并
    for _, s := range slices {
        result = append(result, s...)
    }
    
    return result
}
```

### 总结

在力扣刷题中：
1. **优先使用切片**（90%的情况）
2. **总是预分配容量**（使用`make([]T, length, capacity)`）
3. **考虑是否允许原地修改**来节省内存
4. **注意切片共享底层数组**的问题
5. **数组仅用于固定大小的场景**

# 买卖股票的最佳时机（9.16.3）

## 动态规划解法简述

### 1. 动态规划核心思想

**动态规划就是：将大问题分解为小问题，保存中间结果避免重复计算**

对于这道题：
- **状态定义**：定义`dp[i]`表示第i天能获得的最大利润
- **状态转移**：今天的最大利润 = max(昨天的最大利润, 今天价格 - 历史最低价)

### 2. 具体解法

```go
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    
    //记录最大利润结果和当前最低价
    minPrice := prices[0]
    maxProfit := 0

    //遍历数组 最低价买后找最大利润
    for _,price := range prices{
        //更新现有最低价
        if price < minPrice{
            minPrice = price
        }
        //更新最大利润
        if price-minPrice > maxProfit{
            maxProfit = price-minPrice
        }
    } 
    return maxProfit
}
```

### 3. 动态规划四要素

#### (1) 状态定义

- `minPrice`：到当前为止的历史最低买入价格
- `maxProfit`：到当前为止的最大利润

#### (2) 状态转移方程
```
minPrice = min(minPrice, 当前价格)
maxProfit = max(maxProfit, 当前价格 - minPrice)
```

#### (3) 初始状态
```go
minPrice = prices[0]  // 第一天只能买入
maxProfit = 0         // 第一天不能卖出，利润为0
```

#### (4) 遍历顺序

从第二天开始遍历到最后一天

### 4. 动态规划思维模式

| 步骤        | 内容                         | 本题示例                 |
| ----------- | ---------------------------- | ------------------------ |
| 1. 定义状态 | 用什么变量表示问题状态       | `minPrice`, `maxProfit`  |
| 2. 状态转移 | 当前状态如何从前一个状态得来 | 比较当前价格与历史最低价 |
| 3. 初始条件 | 最开始的状态是什么           | 第一天的情况             |
| 4. 计算顺序 | 按什么顺序计算状态           | 从左到右遍历             |

### 5. 为什么这是动态规划？

虽然代码看起来简单，但它包含了动态规划的所有要素：
- **最优子结构**：今天的最大利润依赖于之前的最优解（历史最低价）
- **重叠子问题**：每个状态都重复使用之前计算的结果
- **状态保存**：用变量保存中间计算结果

### 6. 更直观的理解

想象你每天都在做决策：
- **第i天**：我可以选择在今天卖出
- **最大利润** = 今天价格 - 历史最低价
- **只需要记住**：到目前为止的历史最低价和最大利润

### 7. 时间复杂度：O(n)
### 8. 空间复杂度：O(1)

这就是动态规划的威力：用最少的空间和時間解决复杂问题！

**总结**：动态规划就是通过保存中间结果，避免重复计算，从而高效解决问题。这道题是学习动态规划的完美入门题目！

# 买卖股票的最佳时机 II（9.16.4）

## 动态规划

```go
func maxProfit(prices []int) int {
    //初始化记录表 上面是序号 下面是需要投入的成本
    length := len(prices)
    dp := make([][2]int, length)
    dp[0][1] = -prices[0]
    //0表示手里没有股票的最大利润、1表示交易完后手里持有一支股票的最大利润
    for i := 1; i < length; i++ {
        //前者是一直不交易的 后者是今天给股票卖了 的收益
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        //前者是今天不抛售 后者是之前不持股但是今天买进
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[length-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 贪心算法

```go
func maxProfit(prices []int) (ans int) {
    for i := 1; i < len(prices); i++ {
        ans += max(0, prices[i]-prices[i-1])
    }
    return
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

这个算法模拟的是下面这个过程：

![image-20250916112500173](../图片/贪心算法过程解释.png)

并非去进行了交易，而是通过减法找到了高低差。然后我们充分利用每一段高低差（这个适合没有手续费的情况）

# 跳跃游戏（9.17.1）





# 跳跃游戏 II（9.17.2）





# H 指数（9.17.3）





# O(1) 时间插入、删除和获取随机元素（9.17.4）